<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PiCpo的阁楼</title>
  
  
  <link href="https://picpo.top/atom.xml" rel="self"/>
  
  <link href="https://picpo.top/"/>
  <updated>2025-07-23T05:07:18.326Z</updated>
  <id>https://picpo.top/</id>
  
  <author>
    <name>PiCpo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pixie焊接和验机记录</title>
    <link href="https://picpo.top/2025/07/23/pixie%E7%84%8A%E6%8E%A5%E5%92%8C%E9%AA%8C%E6%9C%BA%E8%AE%B0%E5%BD%95/"/>
    <id>https://picpo.top/2025/07/23/pixie%E7%84%8A%E6%8E%A5%E5%92%8C%E9%AA%8C%E6%9C%BA%E8%AE%B0%E5%BD%95/</id>
    <published>2025-07-23T04:42:53.000Z</published>
    <updated>2025-07-23T05:07:18.326Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202507231248337.jpg" alt=""></p><h2 id="0x00写在前面">0x00写在前面</h2><p>今天验机了，很遗憾大失败。主要的问题有两个：一个是未发射就有杂波；第二个是杂散未能小于-30db（测试下大概16左右）。负责人跟我说之前也有一些人来测试自制pixie套件，但是只有一位通过了验机。这位用的是自己的改进方案而非公版，而公版方案虽说几十年了但是在验机方面也不甚理想。但唯一可庆幸（嘴硬）的是，机器至少能运行（</p><p>由于验机失败，所以笔者不建议新手ham通过自制pixie进行短波执照办理。</p><h2 id="0x01制作过程">0x01制作过程</h2><p>套件是在淘宝上买的，价格不贵，20元以内。以下是焊接过程参考（由于传照片麻烦就直接附上我在焊接时的参考了）</p><p><a href="https://www.kechuang.org/s/dt3r06ps">古人新年新作品之HAM篇：PIXIE QRP CW 收发信机制作</a></p>]]></content>
    
    
    <summary type="html">0x00写在前面
今天验机了，很遗憾大失败。主要的问题有两个：一个是未发射就有杂波；第二个是杂散未能小于-30db（测试下大概16左右）。负责人跟我说之前也有一些人来测试自制pixie套件，但是只有一位通过了验机。这位用的是自己的改进方案而非公版，而公版方案虽说几十年了但是在验机方面也不甚理想。但唯一可庆幸（嘴硬）的是，机器至少能运行（

由于验机失败，所以笔者不建议新手ham通过自制pixie进行短波执照办理。

0x01制作过程
套件是在淘宝上买的，价格不贵，20元以内。以下是焊接过程参考（由于传照片麻烦就直接附上我在焊接时的参考了）

古人新年新作品之HAM篇：PIXIE QRP CW </summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="HAM" scheme="https://picpo.top/tags/HAM/"/>
    
    <category term="业余无线电" scheme="https://picpo.top/tags/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>qBittorrent迁移</title>
    <link href="https://picpo.top/2025/07/17/qBittorrent%E8%BF%81%E7%A7%BB/"/>
    <id>https://picpo.top/2025/07/17/qBittorrent%E8%BF%81%E7%A7%BB/</id>
    <published>2025-07-17T11:10:59.000Z</published>
    <updated>2025-07-17T11:21:49.251Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202507171913751.png" alt=""></p><p>之前玩的几个PT站基本都毕业了，很久没开NAS了。除了某站点以外，其他站点都难通过签到获取一些魔力值。于是打算把之前当电子书战士时的资源迁到不怎么耗电且7x24h开着的服务器上做种去。</p><p>看了一眼一共有2969个做种文件，光搬对应文件还不够，还得把qBit目录下的元数据一起迁移过去。</p><p>qBit的种子数据文件是在<code>~/.local/share/qBittorrent/BT_backup/</code>里，为了不麻烦我直接就把上一级的文件夹直接scp过去了。</p><p>scp前修改了一下<code>/etc/ssh/sshd_config</code>，暂时允许密码登陆。</p>]]></content>
    
    
    <summary type="html">之前玩的几个PT站基本都毕业了，很久没开NAS了。除了某站点以外，其他站点都难通过签到获取一些魔力值。于是打算把之前当电子书战士时的资源迁到不怎么耗电且7x24h开着的服务器上做种去。

看了一眼一共有2969个做种文件，光搬对应文件还不够，还得把qBit目录下的元数据一起迁移过去。

qBit的种子数据文件是在~/.local/share/qBittorrent/BT_backup/里，为了不麻烦我直接就把上一级的文件夹直接scp过去了。

scp前修改了一下/etc/ssh/sshd_config，暂时允许密码登陆。</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="服务器" scheme="https://picpo.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="Linux" scheme="https://picpo.top/tags/Linux/"/>
    
    <category term="NAS" scheme="https://picpo.top/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>macOS清理右键菜单中的打开方式</title>
    <link href="https://picpo.top/2025/02/10/macOS%E5%88%A0%E9%99%A4%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%BD%99%E6%88%96%E6%98%AF%E6%97%A0%E6%95%88%E7%9A%84%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
    <id>https://picpo.top/2025/02/10/macOS%E5%88%A0%E9%99%A4%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%BD%99%E6%88%96%E6%98%AF%E6%97%A0%E6%95%88%E7%9A%84%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/</id>
    <published>2025-02-10T09:39:06.000Z</published>
    <updated>2025-02-10T09:46:26.899Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202502101744051.jpg" alt=""></p><p>命令行执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -kill -r -domain local -domain system-domainuser</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">命令行执行：

1


/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -kill -r -domain local -domain system-domainuser</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="macOS" scheme="https://picpo.top/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>linux下的crazydiskinfo</title>
    <link href="https://picpo.top/2024/10/27/linux%E4%B8%8B%E7%9A%84crazydiskinfo/"/>
    <id>https://picpo.top/2024/10/27/linux%E4%B8%8B%E7%9A%84crazydiskinfo/</id>
    <published>2024-10-27T09:00:23.000Z</published>
    <updated>2024-10-27T09:06:26.344Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410271701465.jpg" alt=""></p><p>CrazyDiskInfo是一款用于Unix类系统的交互式TUI S.M.A.R.T查看器，可以查看硬盘健康情况，是否有坏扇区等。</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410271705139.png" alt=""></p><p>然而国内的教程太垃圾了，多少年前的还在互相抄，抄来抄去的还只有自己编译这条路。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/otakuto/crazydiskinfo</span><br></pre></td></tr></table></figure><p>本文并不反对你去源码编译，只作为存档记录一下获取安装包的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ftp.debian.org/debian/pool/main/c/crazydiskinfo/</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410271705493.png" alt=""></p>]]></content>
    
    
    <summary type="html">CrazyDiskInfo是一款用于Unix类系统的交互式TUI S.M.A.R.T查看器，可以查看硬盘健康情况，是否有坏扇区等。



然而国内的教程太垃圾了，多少年前的还在互相抄，抄来抄去的还只有自己编译这条路。

1


https://github.com/otakuto/crazydiskinfo


本文并不反对你去源码编译，只作为存档记录一下获取安装包的方法。

1


https://ftp.debian.org/debian/pool/main/c/crazydiskinfo/</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="服务器" scheme="https://picpo.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="Linux" scheme="https://picpo.top/tags/Linux/"/>
    
    <category term="运维" scheme="https://picpo.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>服务器更新指南</title>
    <link href="https://picpo.top/2024/10/22/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E6%96%B0%E6%8C%87%E5%8D%97/"/>
    <id>https://picpo.top/2024/10/22/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9B%B4%E6%96%B0%E6%8C%87%E5%8D%97/</id>
    <published>2024-10-22T14:59:16.000Z</published>
    <updated>2024-10-27T07:11:01.498Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410222307533.png" alt=""></p><h2 id="0x00前言">0x00前言</h2><p>之前的nas太菜了，MC服务器带不动，功耗也高，正好之前断头+碎显示屏的yoga14c2021已经在家里吃灰一年多了，说实话1135G7就算再菜他也是比4160强，功耗还低，并且多了个电池做内部UPS（</p><h2 id="0x01去头">0x01去头</h2><p>屏幕碎了，其原因是转轴寄了（再次奉劝任何想买联想机器的朋友，你即使不怕计划报废买了后也记得延保），必须得把这玩意整下来才方便我后续操作。</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410222312531.jpeg" alt=""></p><p>我是很想把下图的在机身的转轴铰链搞下来的，但问题是他被主板压着，而主板又是被散热器+模块+电池压着，所以总的来说施工风险很高，也很麻烦，我就直接把屏幕从铰链上拆下来了，所以最后还会留着两边两个小铰链，不过无伤大雅。</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410222345692.jpeg" alt=""></p><p>排线也拔了，最后效果还不错，已经是我想要的状态了</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410222318762.jpeg" alt=""></p><h2 id="0x02系统迁移">0x02系统迁移</h2><p>这个本来没啥好说的，主要是被联想bios坑了。我无论是在liveCD里用GParted快速迁移还是dd缓慢迁移，他的BIOS都不认我的盘，查了半天也确实是GPT引导完全没有问题。</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410222323308.jpeg" alt=""></p><p>搞半天试了一下修复分区就好了，我服了。</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410222324164.jpeg" alt=""></p><p>新机器的效能还是很不错的，发一下前后对比：</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410222329215.png" alt=""></p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410222330804.png" alt=""></p><h2 id="0x03服务恢复">0x03服务恢复</h2><p>记录一下恢复服务时踩的坑吧：</p><p>第一个就是桌面的锅了，一开始测试时进的就是桌面，结果MC服务器测试15分钟时断开链接了，一拍脑袋才发现忘记关了15分钟休眠的选项。</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410222334301.png" alt=""></p><p>第二天早上起来发现service19个failed，问了一下群友这sddm不disable不行。重启之后就没报过错了；而且之前有个核心偶尔会占用100%，内存占用也是一口气吃了8G，我怀疑都是桌面导致的，现在cpu内存占用都很低了。</p><p>第二个坑就是迁移nextcloud和navidrome时发生的了，这两个服务的数据文件都在我的raid1阵列上，但是我现在只有一个硬盘盒，易驱线明天才到。</p><p>我一开始打算在Windows上读取单个盘，但是花了很多时间还失败了（在此之前我尝试连到Mac上，但是无法识别，这也是导致我步入windows上歧途的原因）。随后直接挂载服务器上得了，没想到一下子就读取到了</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410222338850.png" alt=""></p><p>后面迁移nextcloud服务时出现了读写问题，原因是文件夹owner是www-data，而我sudo cp下直接导致变成了root，解决方法也简单，加个-p就能保留源文件的权限、所有者和时间戳信息。</p><h2 id="0x04硬件堆放">0x04硬件堆放</h2><p>硬盘这块，买的是亚克力板子+泡沫海绵垫，用的是易驱线+12V3A圆口电源。</p><p><strong><u>注意！这并不是一个很好的方案，可能会导致硬盘升天数据丢失，请勿模仿。</u></strong></p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410231203826.jpeg" alt=""></p><p>另外一开始买的是USB2.0，收货后发现的问题是USB2.0只能驱动2TB以下的硬盘，很神奇。USB2.0很便宜一根几块钱，但是3.0就很贵了得25元。</p><p>装的过程中还遇到了电源大小问题，如图所见这个玩意插上去后会导致相邻的插座无法插任何东西，好在旁边还有个拖线板，可以把电脑的电源插到那块儿去。</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410251830644.png" alt=""></p><p>好了之后测试了一下，发现速度不敢恭维，只有30-50MB/s，不如以前插在SATA线快。但是这也没办法，另外同样有群友也有类似的问题，也是在Linux下限速但是Windows就正常了。不过这些都是小问题，总之我觉得这一套下来功耗和性能都有加强，只是灵车程度也比之前灵车多了，或许过段时间我会整篇新文章来说说翻车后抢救过程（bushi</p><h2 id="0x05-已老实">0x05 已老实</h2><p>昨天的我：先相信</p><p>今天的我：已投降</p><p>先说原因：第一点是易驱线质量很差，4T的盘没问题，8T的盘隔一会儿就会掉盘；其次是Linux下使用外接HDD速度奇慢，我和身边的朋友以及网络上都有同样的案例，同样的外接硬盘在Windows上能跑满速度，但是接在Linux上只有30MB/s，跑不到lsusb里5Gbps的USB3.0协议（当然这个问题出现的人很多，也有朋友没有这个问题，这个我就不得而知了）</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410271504160.png" alt=""></p><p>现在换成sata了，速度正常了，那么老机器就用来刷pt了。</p>]]></content>
    
    
    <summary type="html">0x00前言
之前的nas太菜了，MC服务器带不动，功耗也高，正好之前断头+碎显示屏的yoga14c2021已经在家里吃灰一年多了，说实话1135G7就算再菜他也是比4160强，功耗还低，并且多了个电池做内部UPS（

0x01去头
屏幕碎了，其原因是转轴寄了（再次奉劝任何想买联想机器的朋友，你即使不怕计划报废买了后也记得延保），必须得把这玩意整下来才方便我后续操作。



我是很想把下图的在机身的转轴铰链搞下来的，但问题是他被主板压着，而主板又是被散热器+模块+电池压着，所以总的来说施工风险很高，也很麻烦，我就直接把屏幕从铰链上拆下来了，所以最后还会留着两边两个小铰链，不过无伤大雅。



</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="服务器" scheme="https://picpo.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="Linux" scheme="https://picpo.top/tags/Linux/"/>
    
    <category term="运维" scheme="https://picpo.top/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>ARM64（M1版）架构下macOS运行ALAS脚本</title>
    <link href="https://picpo.top/2024/10/15/ARM64%EF%BC%88M1%E7%89%88%EF%BC%89%E6%9E%B6%E6%9E%84%E4%B8%8BmacOS%E8%BF%90%E8%A1%8CALAS%E8%84%9A%E6%9C%AC/"/>
    <id>https://picpo.top/2024/10/15/ARM64%EF%BC%88M1%E7%89%88%EF%BC%89%E6%9E%B6%E6%9E%84%E4%B8%8BmacOS%E8%BF%90%E8%A1%8CALAS%E8%84%9A%E6%9C%AC/</id>
    <published>2024-10-15T12:00:29.000Z</published>
    <updated>2024-10-15T13:44:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410152008286.png" alt=""></p><h2 id="0x00前言">0x00前言</h2><p>首先感谢Github上面MAA以及AzurLaneAutoScript的开发组，让我们有工具可用。再感谢@吕明珠LmeSzinc 、@binss以及chenhuan20123 大佬，他们的教程让我受益良多。</p><h2 id="0x01模拟器">0x01模拟器</h2><p>安卓官方的模拟器能用，安装吧，我也想运行原生游戏安装包，但是alas似乎只能用adb进行一些操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/google/android-emulator-m1-preview/releases/download/0.3/android-emulator-m1-preview.dmg</span><br></pre></td></tr></table></figure><p>这个不用下载android studio，非常好（</p><p>安装后不能直接打开，需要提前进入 <code>Android Emulator.app/Contents/MacOS/api30-gphone-arm64-v8a/config.ini</code>这里面进行一些修改（非常抽象的是，如果你运行后再试图进行修改无论如何也是失效的，只能重新安装），以下是一些需要更改的字段</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">硬盘空间：<span class="attr">disk.dataPartition.size</span>=<span class="number">20480</span>M   //我直接加了个<span class="number">0</span>，因为游戏下载所有资源后也差不多这么大</span><br><span class="line">运行内存：<span class="attr">hw.ramSize</span>=<span class="number">4096</span> //我觉得<span class="number">4</span>G够了</span><br><span class="line">DPI：<span class="attr">hw.lcd.density</span>=<span class="number">420</span> //这个不变</span><br><span class="line">显示高度：<span class="attr">hw.lcd.height</span>=<span class="number">720</span></span><br><span class="line">显示宽度：<span class="attr">hw.lcd.width</span>=<span class="number">1280</span></span><br></pre></td></tr></table></figure><p>运行后可能无法直接将游戏安装包拖动到窗口进行安装，说明你缺少adb，可以使用以下命令在macOS安装这些组件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install android-platform-tools</span><br><span class="line">//安装成功后可以输入以下命令获取位置</span><br><span class="line">adb version</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410152022899.png" alt=""></p><p>记得到这个界面给模拟器加上adb路径</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410152024442.png" alt=""></p><h2 id="0x02脚本安装">0x02脚本安装</h2><p>先去项目原地址把代码全部git clone下来到某个位置，保留用。</p><p>其次去拉取binss大佬做的镜像<code>binss/azurlaneautoscript:arm64</code>（本质是为了mxnet1.9.0这个东西，你愿意的话也可以自己编译），然后你就可以运行一下容器了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -e TZ=Asia/Shanghai --volume=你自己放alas的文件夹:/app/AzurLaneAutoScript:rw -p 22267:22267 --name azurlaneautoscript binss/azurlaneautoscript:arm64</span><br></pre></td></tr></table></figure><p>第一次运行时可以运行试试，这个镜像是半年前的，所以里面有些东西确实很正常，你可以在docker桌面端的程序里pip，也可以直接docker exec -it。我看了一下大概缺少了<code>onepush==1.3.0</code>、<code>pydantic==1.10.2</code>、<code>uiautomator2cache==0.3.0.1</code>等这几个。版本号不要照抄，对着requrements.txt文件查；也别一上来就直接安装整个requrements.txt，这会把<a href="https://binsitepublic-10018028.file.myqcloud.com/mxnet-1.9.1-py3-none-any.whl">mxnet-1.9.1</a>顶掉为1.6.0，相当于镜像白装了。</p><h2 id="0x03使用">0x03使用</h2><p>经过几次重启容器，这次大概率可以正常使用了：serial设置为<code>host.docker.internal:5555</code>，截图方案和点击方案我都是ADB。打开webUI后可以测试一下，看看有没有问题。</p><p>有人推荐点击方案是Hermit，但我这偶尔出问题后会自动转为另一个根本不可用的方案，我无语了，目前切换为ADB一点问题都没，后面出了状况再说吧。</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202410152051428.png" alt=""></p>]]></content>
    
    
    <summary type="html">0x00前言
首先感谢Github上面MAA以及AzurLaneAutoScript的开发组，让我们有工具可用。再感谢@吕明珠LmeSzinc 、@binss以及chenhuan20123 大佬，他们的教程让我受益良多。

0x01模拟器
安卓官方的模拟器能用，安装吧，我也想运行原生游戏安装包，但是alas似乎只能用adb进行一些操作

1


https://github.com/google/android-emulator-m1-preview/releases/download/0.3/android-emulator-m1-preview.dmg


这个不用下载android st</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="macOS" scheme="https://picpo.top/tags/macOS/"/>
    
    <category term="碧蓝航线" scheme="https://picpo.top/tags/%E7%A2%A7%E8%93%9D%E8%88%AA%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Linux全盘备份指南</title>
    <link href="https://picpo.top/2024/07/30/Linux%E5%85%A8%E7%9B%98%E5%A4%87%E4%BB%BD%E6%8C%87%E5%8D%97/"/>
    <id>https://picpo.top/2024/07/30/Linux%E5%85%A8%E7%9B%98%E5%A4%87%E4%BB%BD%E6%8C%87%E5%8D%97/</id>
    <published>2024-07-30T04:53:28.000Z</published>
    <updated>2024-09-16T18:31:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202407301307619.png" alt=""></p><p>难绷之灵车服务器的系统盘炸了，损失极其惨重，这几天重新装了个Debian系统，想着有必要搞一个全盘备份系统的功能（数据备份真的很重要QAQ）。</p><p>目前用的是dd+alist+rclone，原理就是dd全盘备份+压缩+alist挂载各种云盘+rclone上传到alist的webdav上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份并压缩脚本</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否具有root权限</span></span><br><span class="line">if [ &quot;$EUID&quot; -ne 0 ]; then</span><br><span class="line">  echo &quot;请使用root权限运行此脚本&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否传入了源磁盘和目标目录</span></span><br><span class="line">if [ $# -ne 2 ]; then</span><br><span class="line">  echo &quot;使用方法: $0 &lt;源磁盘&gt; &lt;目标目录&gt;&quot;</span><br><span class="line">  echo &quot;例如: $0 /dev/sda /path/to/backup_directory&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">SOURCE_DISK=$1</span><br><span class="line">TARGET_DIR=$2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确认源磁盘存在</span></span><br><span class="line">if [ ! -b &quot;$SOURCE_DISK&quot; ]; then</span><br><span class="line">  echo &quot;源磁盘不存在: $SOURCE_DISK&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确认目标目录存在</span></span><br><span class="line">if [ ! -d &quot;$TARGET_DIR&quot; ]; then</span><br><span class="line">  echo &quot;目标目录不存在: $TARGET_DIR&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成目标文件名，使用下划线分割年月日时间</span></span><br><span class="line">TIMESTAMP=$(date +&quot;%Y_%m_%d_%H_%M_%S&quot;)</span><br><span class="line">TARGET_FILE=&quot;$TARGET_DIR/backup_$TIMESTAMP.img.gz&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份磁盘并压缩到目标文件</span></span><br><span class="line">echo &quot;开始备份并压缩 $SOURCE_DISK 到 $TARGET_FILE ...&quot;</span><br><span class="line">dd if=$SOURCE_DISK bs=4M status=progress | gzip &gt; $TARGET_FILE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查备份是否成功</span></span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">  echo &quot;备份并压缩成功: $TARGET_FILE&quot;</span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">使用rclone将备份文件移动到远程存储</span></span><br><span class="line">  echo &quot;开始将备份文件移动到远程存储...&quot;</span><br><span class="line">  rclone move $TARGET_FILE backup:/backup -P --no-check-certificate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">检查rclone是否成功</span></span><br><span class="line">  if [ $? -eq 0 ]; then</span><br><span class="line">    echo &quot;备份文件移动成功&quot;</span><br><span class="line">  else</span><br><span class="line">    echo &quot;备份文件移动失败&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line">else</span><br><span class="line">  echo &quot;备份并压缩失败&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>保存这个脚本到一个文件中，比如<code>backup_and_compress_with_timestamp.sh</code>，然后给它可执行权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x backup_and_compress_with_timestamp.sh</span><br><span class="line">sudo ./backup_and_compress_with_timestamp.sh /dev/sda /path/to/backup_directory</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202407301332892.png" alt=""></p>]]></content>
    
    
    <summary type="html">难绷之灵车服务器的系统盘炸了，损失极其惨重，这几天重新装了个Debian系统，想着有必要搞一个全盘备份系统的功能（数据备份真的很重要QAQ）。

目前用的是dd+alist+rclone，原理就是dd全盘备份+压缩+alist挂载各种云盘+rclone上传到alist的webdav上：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="linux" scheme="https://picpo.top/tags/linux/"/>
    
    <category term="Debian" scheme="https://picpo.top/tags/Debian/"/>
    
  </entry>
  
  <entry>
    <title>AFP与Time Machine</title>
    <link href="https://picpo.top/2023/05/01/AFP%E4%B8%8ETime%20Machine/"/>
    <id>https://picpo.top/2023/05/01/AFP%E4%B8%8ETime%20Machine/</id>
    <published>2023-05-01T12:25:18.000Z</published>
    <updated>2024-09-16T18:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/20230501204251.png" alt=""></p><h2 id="0x01安装">0x01安装</h2><p>安装Netatalk服务，用来把Linux/Unix伪装成AFP协议传输的文件服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install netatalk</span><br></pre></td></tr></table></figure><p>安装avahi-daemon，用来在Linux/Unix中开启类似的Bonjour的服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install avahi-daemon</span><br></pre></td></tr></table></figure><h2 id="0x02配置文件">0x02配置文件</h2><p>编辑<code>/etc/netatalk/afp.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">; Netatalk 3.x configuration file</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">[Global]</span><br><span class="line">; Global server settings</span><br><span class="line"></span><br><span class="line">; [Homes]</span><br><span class="line">; basedir regex = /xxxx</span><br><span class="line"></span><br><span class="line">; [My AFP Volume]</span><br><span class="line">; path = /path/to/volume</span><br><span class="line"></span><br><span class="line">; [My Time Machine Volume]</span><br><span class="line">; path = /path/to/backup</span><br><span class="line">; time machine = yes</span><br><span class="line"></span><br><span class="line">[PiCpo Time Machine]</span><br><span class="line">path = /mnt/HGST01/Time ;这是我挂载的文件目录</span><br><span class="line">time machine = yes</span><br><span class="line">valid users = user ;选择登陆的用户</span><br></pre></td></tr></table></figure><p>最后别忘了restart</p><p>选择添加afp://ip再输入用户名密码就能连接到自己的Time Machine服务器了</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/3145f8286ec543689a6b0a8614a2843e.jpeg" alt=""></p>]]></content>
    
    
    <summary type="html">0x01安装
安装Netatalk服务，用来把Linux/Unix伪装成AFP协议传输的文件服务器：

1


sudo apt-get install netatalk


安装avahi-daemon，用来在Linux/Unix中开启类似的Bonjour的服务：

1


sudo apt-get install avahi-daemon


0x02配置文件
编辑/etc/netatalk/afp.conf

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21


;
; Netatalk 3.x configuration fil</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="linux" scheme="https://picpo.top/tags/linux/"/>
    
    <category term="AFP" scheme="https://picpo.top/tags/AFP/"/>
    
    <category term="ubuntu" scheme="https://picpo.top/tags/ubuntu/"/>
    
    <category term="Time Machine" scheme="https://picpo.top/tags/Time-Machine/"/>
    
  </entry>
  
  <entry>
    <title>家用服务器折腾指南</title>
    <link href="https://picpo.top/2023/01/15/%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97/"/>
    <id>https://picpo.top/2023/01/15/%E5%AE%B6%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97/</id>
    <published>2023-01-15T10:14:03.000Z</published>
    <updated>2024-09-16T18:32:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202301151847944.jpg" alt=""></p><h2 id="0x00写在前面">0x00写在前面</h2><p>去年暑假组了一台新电脑，老电脑逐渐用不上用场了。恰好我有刷pt的需求，还想运行MC等游戏的服务器，于是我就动手改造这台老电脑了。</p><h2 id="0x01硬件配置">0x01硬件配置</h2><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202301151851767.png" alt=""></p><p>这台老电脑是15年配的：CPU是i3-4160，两个核心四个线程；主板是技嘉的丐版H81M-D2，有两个内存插槽，最大只支持8G的DDR3内存；主板有三个PCIE接口，一个PCIEx16够宽，两个PCIEx1比较短；还有四个SATA接口；另外主板太老没有HDMI只有VGA接口，除此之外的千兆以太网口没啥好说的</p><p>PCIEx16上的亮机卡是GT640 2G，其实就是装系统时候用的；PCIEx1装了个物联网开机模块，因为我要将其放到家中，而我常年在外面上学，所以这个必不可少；还有个PCIEx1是英特尔Intel Corporation Wireless 7260网卡，这个是当时在学校里倒腾这玩意时应急选项，因为当初交换机太远，显示器太近。</p><p>内存的话，只插了一根8G的DDR3内存，没想插更多是因为没有那么多服务要跑。当然了，高版本的MC多少内存都不够，不够我的U似乎也有些捉襟见肘了。</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202301151912133.png" alt=""></p><p>SATA四个接口全被占用啦。一个是系统盘，威刚的远古120G固态盘；一个两百块淘来的4THGST企业盘，是真的吵，也是真的烫，为此我加了个风扇改变风道，用来刷刷PT还是比较够的；之前云盘服务是在日立盘上的，但这小文件读写实在是太吵了，也不安全，于是26块包邮搞了块500G西数蓝盘，配上闲置的500G西数绿盘，组了个RAID1阵列，图个心安吧，这个阵列就是专门做云盘备份了。</p><h2 id="0x02系统与网络配置">0x02系统与网络配置</h2><p>系统没啥好说的，本人不喜欢折腾，也就没有搞ESXi，我系统盘实在是太小了，我为了配置方便就直接装Ubuntu 22.04.1 LTS了。</p><p>网络的话，我家里是楼上楼下；光猫先是进入一楼的房间，通过院子里的飞线飞到二楼客厅弱电箱的交换机里。一路上的路由器我全改为了mesh组网，这是为了保证每个设备都能拿到ipv6。另外，据修网的师傅所言，上海电信的SDN只有在有公网的情况下才能正常使用ipv6（我不理解），于是我也拿到了我的一个公网v4地址，管他静态还是动态（半个多月都没改变地址），能有就是赢麻了！v4的话不支持NAT回流，就是我内网的主机没法用公网IP访问我的设备；但是v6没有公网内网之分，没有问题；还有就是v4v6都被封了80，443，8080端口。</p><h2 id="0x03游戏服务器">0x03游戏服务器</h2><p>这个配置拿来刷pt和做NAS（不考虑转码）其实是有些暴殄天物了，刚好我的云服务器也到期了，于是就把我的游戏服务器全都迁移到家里。</p><h3 id="1-MC运维面板MCSManager">1.MC运维面板MCSManager</h3><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202301151920251.png" alt=""></p><p>Aimed to provide a healthy software support for server administrators of Minecraft, Terraria and other game servers.</p><p>官网地址：<a href="https://mcsmanager.com/">https://mcsmanager.com/</a></p><p>这个东西简直不要太好用！我之前在云服务器上搭建的我的世界服务器，经常要不停地按UP键找历史命令，有一次还输入错误导致存档没了，非常可惜；如果想做备份和其他计划任务，说不难也不难，shell和crontab看着文档就能写出想要的东西了。但这些繁琐危险的操作本可以避免，在MCSManager里，你可以很方便地在网页端执行命令、修改配置文件、上传整合包、设定计划任务，甚至可以说，他就是一个网页Linux周期命令执行器。另外本身自带一些api，在我的NekobotQQ机器人还活着时，无需打开游戏戳一戳她就显示服务器情况和人数。</p><p>安装很简单，官网提供了wget下载的安装脚本和docker安装方式，我是推荐用wget：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/mcsmanager/Script/master/setup_en.sh | bash</span><br></pre></td></tr></table></figure><h3 id="2-SteamCMD">2.SteamCMD</h3><p>SteamCMD is the command line version of the Steam client. The tool is used <strong>to download dedicated server applications of popular Steam games quickly  and easily for running your own Valheim server or Rust server</strong>, for example.</p><p>官方网址：<a href="https://developer.valvesoftware.com/wiki/SteamCMD">https://developer.valvesoftware.com/wiki/SteamCMD</a></p><p>也挺好安装的，具体方法包括在我之前写的<a href="https://picpo.top/2022/01/18/%E5%9C%A8linux%E5%B9%B3%E5%8F%B0%E4%B8%8A%E6%90%AD%E5%BB%BA%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF%E6%9C%8D%E5%8A%A1%E5%99%A8/">在linux平台上搭建求生之路服务器</a>里。要注意的是，SteamCMD似乎是能被MCSManager原生识别的，但是其权限问题错综复杂无法访问到一些文件，本人水平不够没有细究（懒），所以就ssh后screen运维拉到。</p><p>服务器上跑了求生之路和饥荒的服务器，很可惜这两个游戏都原生不支持ipv6，但还好我本身就有公网v4😋。</p><h2 id="0x04运维组件">0x04运维组件</h2><p>SSH和Linux谁都会，但这些繁琐的操作都是可以避免的。</p><h3 id="1-DDNS-GO">1.DDNS-GO</h3><p>官方网址：<a href="https://github.com/jeessy2/ddns-go">https://github.com/jeessy2/ddns-go</a></p><p>这是一个用go写的ddns，且不说我的v4很有可能是动态的，ipv6可是每两天就变化一次的，所以有个ddns服务非常有必要。</p><p>我的安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name ddns-go --restart=always --net=host -v /opt/ddns-go:/root jeessy/ddns-go</span><br></pre></td></tr></table></figure><h3 id="2-性能监控-运维Cockpit">2.性能监控&amp;运维Cockpit</h3><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202301151939945.webp" alt=""></p><p>这个是Fedora Server自带的面板，作为debian系的Ubuntu肯定也能装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cockpit -y</span><br></pre></td></tr></table></figure><p>多的不说，光Storage能帮你格式化、分区、组软RAID就已经很好了。界面很素，但是很好用。</p><p>安全性有自签名证书，不放心可以搞个其他的。</p><h3 id="3-Portainer">3.Portainer</h3><p>Deploy, configure, troubleshoot and secure containers in minutes  on Kubernetes, Docker, Swarm and Nomad in any data center, cloud,  network edge or IIOT device.</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202301151945605.webp" alt=""></p><p>官方网址：<a href="https://www.portainer.io/">https://www.portainer.io/</a></p><p>这个没啥好说，管理docker容器的。我有太多服务是依赖docker快速启动的了。</p><p>我的安装方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull portainer/portainer:latest</span><br><span class="line"></span><br><span class="line">docker run -d --net=host --restart=unless-stopped -v /var/run/docker.sock:/var/run/docker.sock -v /data/portainer_data:/data portainer/portainer:1.23.2</span><br></pre></td></tr></table></figure><h2 id="0x05其他服务">0x05其他服务</h2><h3 id="1-transmission-daemon">1.transmission-daemon</h3><p>磁力下载工具，主要用来刷pt。</p><p>我的安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install transmission-daemon</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原版界面太素，信息不够详尽，推荐用这个改善：</p><p><a href="https://github.com/ronggang/transmission-web-control">https://github.com/ronggang/transmission-web-control</a></p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202301151954452.png" alt=""></p><h3 id="2-LibreSpeed">2.LibreSpeed</h3><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202302041435726.png" alt=""></p><p>测速服务器。官方网址：<a href="https://github.com/librespeed/speedtest-go">https://github.com/librespeed/speedtest-go</a></p><p>我的安装方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull badapple9/speedtest-x</span><br><span class="line"></span><br><span class="line">docker run -d --restart=always --name speedtest -p 9001:80 -it badapple9/speedtest-x</span><br></pre></td></tr></table></figure><h3 id="3-Samba服务">3.Samba服务</h3><p>单纯当Nas用的服务</p><p>我的安装方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install samba samba-common</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/samba/smb.conf</span><br><span class="line"></span><br><span class="line">//更多配置字段请查阅Google</span><br><span class="line"></span><br><span class="line">[share]</span><br><span class="line">comment = share folder</span><br><span class="line">browseable = <span class="built_in">yes</span></span><br><span class="line">path = /home/frank/share</span><br><span class="line">create mask = 0700</span><br><span class="line">directory mask = 0700=</span><br><span class="line">public = <span class="built_in">yes</span></span><br><span class="line">available = <span class="built_in">yes</span></span><br><span class="line">writable = <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>重启服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service smbd restart</span><br></pre></td></tr></table></figure><p>推荐给samba新创建一个用户，而不是root和本机用户。</p><h3 id="4-Nextcloud网盘">4.Nextcloud网盘</h3><p>The most popular self-hosted collaboration solution for tens of millions of users at thousands of organizations across the globe</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202301152005332.webp" alt=""></p><p>官方网址：<a href="https://nextcloud.com/">https://nextcloud.com/</a></p><p>我的安装方式是docker而不是官网推荐的docker-compose，因为docker-compose出现了权限读取问题，没解决成功。推荐自己去官网看docker-compose.yml。</p><p>挺好用的，每个平台都有客户端，主要用来同步手机照片和其他文件，当网盘用。</p><h3 id="5-Navidrome私有音乐服务">5.Navidrome私有音乐服务</h3><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202302041438738.png" alt=""></p><p>受不了各大音乐平台的版权壁垒了，官方网址：<a href="https://www.navidrome.org/">https://www.navidrome.org/</a></p><ul><li>几乎可以播放任何音频格式</li><li>多用户，每个用户都有自己的播放次数、播放列表、收藏夹等。</li><li>资源使用率非常低。例如：300GB的资料库（约29000首歌曲），使用不到50MB的内存。</li><li>界面简洁，支持中文。</li><li>支持Subsonic API，也就是说Subsonic能用的客户端，Navidrome都能用。</li></ul><p>唯一的问题就是歌词显示有问题，似乎放到目录里也显示无歌词。</p><p>我的docker-compose.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">navidrome:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">navidrome</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">deluan/navidrome:latest</span></span><br><span class="line">    <span class="attr">user:</span> <span class="number">0</span><span class="string">:0</span> <span class="comment">#0:0代表用root用户运行</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;4533:4533&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># Optional: put your config options customization here. Examples:</span></span><br><span class="line">      <span class="attr">ND_SCANSCHEDULE:</span> <span class="string">1h</span></span><br><span class="line">      <span class="attr">ND_LOGLEVEL:</span> <span class="string">info</span>  </span><br><span class="line">      <span class="attr">ND_SESSIONTIMEOUT:</span> <span class="string">24h</span></span><br><span class="line">      <span class="attr">ND_BASEURL:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">ND_ENABLETRANSCODINGCONFIG:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">      <span class="attr">ND_TRANSCODINGCACHESIZE:</span> <span class="string">&quot;4000M&quot;</span></span><br><span class="line">      <span class="attr">ND_IMAGECACHESIZE:</span> <span class="string">&quot;1000M&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/mnt/WDC/navidrome/data:/data&quot;</span> <span class="string">//数据文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/mnt/WDC/navidrome/media:/music:ro&quot;</span> <span class="string">//媒体文件</span></span><br></pre></td></tr></table></figure><p>以下是支持的客户端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iOS: play:Sub, substreamer, Amperfy, iSub</span><br><span class="line">Android: DSub, Subtracks, subreamer, Ultrasonic, Audinaut</span><br><span class="line">网页端: Subplayer, Airsonic Refix, Aurial, Jamstash, Subfire</span><br><span class="line">桌面端: Sublime Music（Linux）和Sonixd（Windows/Linux/MacOS）</span><br><span class="line">命令行: Jellycli（Windows/Linux）和STMP（Linux/MacOS）</span><br></pre></td></tr></table></figure><h3 id="6-CUPS网络打印机">6.CUPS网络打印机</h3><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cups</span><br></pre></td></tr></table></figure><p>备份文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/cups/cupsd.conf /etc/cups/cupsd.conf.bak</span><br></pre></td></tr></table></figure><p>我的配置文档，仅供参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">LogLevel warn</span><br><span class="line">PageLogFormat</span><br><span class="line">MaxLogSize 0</span><br><span class="line">ErrorPolicy retry-job</span><br><span class="line">//listen需要将localhost改为0.0.0.0，记得防火墙弄好</span><br><span class="line"># Allow remote access</span><br><span class="line">Port 631</span><br><span class="line">Listen /run/cups/cups.sock</span><br><span class="line"># Share local printers on the local network.</span><br><span class="line">Browsing On</span><br><span class="line">BrowseLocalProtocols dnssd</span><br><span class="line">DefaultAuthType Basic</span><br><span class="line">WebInterface Yes</span><br><span class="line">IdleExitTimeout 60</span><br><span class="line"></span><br><span class="line">//这块地方需要修改成这样，否则forbidden</span><br><span class="line">&lt;Location /&gt;</span><br><span class="line">  # Allow shared printing...</span><br><span class="line">  Order allow,deny</span><br><span class="line">  Allow all</span><br><span class="line">&lt;/Location&gt;</span><br><span class="line">&lt;Location /admin&gt;</span><br><span class="line">  AuthType Default</span><br><span class="line">  Require valid-user</span><br><span class="line">&lt;/Location&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;Location /admin/conf&gt;</span><br><span class="line">  AuthType Default</span><br><span class="line">  Require user @SYSTEM</span><br><span class="line">&lt;/Location&gt;</span><br><span class="line">&lt;Location /admin/log&gt;</span><br><span class="line">  AuthType Default</span><br><span class="line">  Require user @SYSTEM</span><br><span class="line">&lt;/Location&gt;</span><br><span class="line">&lt;Policy default&gt;</span><br><span class="line">  JobPrivateAccess default</span><br><span class="line">  JobPrivateValues default</span><br><span class="line">  SubscriptionPrivateAccess default</span><br><span class="line">  SubscriptionPrivateValues default</span><br><span class="line">  &lt;Limit Create-Job Print-Job Print-URI Validate-Job&gt;</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit Send-Document Send-URI Hold-Job Release-Job Restart-Job Purge-Jobs Set-Job-Attributes Create-Job-Subscription Renew-Subscription Cancel-Subscription Get-Notifications Reprocess-Job Cancel-Current-Job Suspend-Current-Job Resume-Job Cancel-My-Jobs Close-Job CUPS-Move-Job CUPS-Get-Document&gt;</span><br><span class="line">    Require user @OWNER @SYSTEM</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit CUPS-Add-Modify-Printer CUPS-Delete-Printer CUPS-Add-Modify-Class CUPS-Delete-Class CUPS-Set-Default CUPS-Get-Devices&gt;</span><br><span class="line">    AuthType Default</span><br><span class="line">    Require user @SYSTEM</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit Pause-Printer Resume-Printer Enable-Printer Disable-Printer Pause-Printer-After-Current-Job Hold-New-Jobs Release-Held-New-Jobs Deactivate-Printer Activate-Printer Restart-Printer Shutdown-Printer Startup-Printer Promote-Job Schedule-Job-After Cancel-Jobs CUPS-Accept-Jobs CUPS-Reject-Jobs&gt;</span><br><span class="line">    AuthType Default</span><br><span class="line">    Require user @SYSTEM</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit Cancel-Job CUPS-Authenticate-Job&gt;</span><br><span class="line">    Require user @OWNER @SYSTEM</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit All&gt;</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">&lt;/Policy&gt;</span><br><span class="line">&lt;Policy authenticated&gt;</span><br><span class="line">  JobPrivateAccess default</span><br><span class="line">  JobPrivateValues default</span><br><span class="line">  SubscriptionPrivateAccess default</span><br><span class="line">  SubscriptionPrivateValues default</span><br><span class="line">  &lt;Limit Create-Job Print-Job Print-URI Validate-Job&gt;</span><br><span class="line">    AuthType Default</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit Send-Document Send-URI Hold-Job Release-Job Restart-Job Purge-Jobs Set-Job-Attributes Create-Job-Subscription Renew-Subscription Cancel-Subscription Get-Notifications Reprocess-Job Cancel-Current-Job Suspend-Current-Job Resume-Job Cancel-My-Jobs Close-Job CUPS-Move-Job CUPS-Get-Document&gt;</span><br><span class="line">    AuthType Default</span><br><span class="line">    Require user @OWNER @SYSTEM</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit CUPS-Add-Modify-Printer CUPS-Delete-Printer CUPS-Add-Modify-Class CUPS-Delete-Class CUPS-Set-Default&gt;</span><br><span class="line">    AuthType Default</span><br><span class="line">    Require user @SYSTEM</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit Pause-Printer Resume-Printer Enable-Printer Disable-Printer Pause-Printer-After-Current-Job Hold-New-Jobs Release-Held-New-Jobs Deactivate-Printer Activate-Printer Restart-Printer Shutdown-Printer Startup-Printer Promote-Job Schedule-Job-After Cancel-Jobs CUPS-Accept-Jobs CUPS-Reject-Jobs&gt;</span><br><span class="line">    AuthType Default</span><br><span class="line">    Require user @SYSTEM</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit Cancel-Job CUPS-Authenticate-Job&gt;</span><br><span class="line">    AuthType Default</span><br><span class="line">    Require user @OWNER @SYSTEM</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit All&gt;</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">&lt;/Policy&gt;</span><br><span class="line">&lt;Policy kerberos&gt;</span><br><span class="line">  JobPrivateAccess default</span><br><span class="line">  JobPrivateValues default</span><br><span class="line">  SubscriptionPrivateAccess default</span><br><span class="line">  SubscriptionPrivateValues default</span><br><span class="line">  &lt;Limit Create-Job Print-Job Print-URI Validate-Job&gt;</span><br><span class="line">    AuthType Negotiate</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit Send-Document Send-URI Hold-Job Release-Job Restart-Job Purge-Jobs Set-Job-Attributes Create-Job-Subscription Renew-Subscription Cancel-Subscription Get-Notifications Reprocess-Job Cancel-Current-Job Suspend-Current-Job Resume-Job Cancel-My-Jobs Close-Job CUPS-Move-Job CUPS-Get-Document&gt;</span><br><span class="line">    AuthType Negotiate</span><br><span class="line">    Require user @OWNER @SYSTEM</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit CUPS-Add-Modify-Printer CUPS-Delete-Printer CUPS-Add-Modify-Class CUPS-Delete-Class CUPS-Set-Default&gt;</span><br><span class="line">    AuthType Default</span><br><span class="line">    Require user @SYSTEM</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit Pause-Printer Resume-Printer Enable-Printer Disable-Printer Pause-Printer-After-Current-Job Hold-New-Jobs Release-Held-New-Jobs Deactivate-Printer Activate-Printer Restart-Printer Shutdown-Printer Startup-Printer Promote-Job Schedule-Job-After Cancel-Jobs CUPS-Accept-Jobs CUPS-Reject-Jobs&gt;</span><br><span class="line">    AuthType Default</span><br><span class="line">    Require user @SYSTEM</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit Cancel-Job CUPS-Authenticate-Job&gt;</span><br><span class="line">    AuthType Negotiate</span><br><span class="line">    Require user @OWNER @SYSTEM</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">  &lt;Limit All&gt;</span><br><span class="line">    Order deny,allow</span><br><span class="line">  &lt;/Limit&gt;</span><br><span class="line">&lt;/Policy&gt;</span><br></pre></td></tr></table></figure><p>重启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service cups restart</span><br></pre></td></tr></table></figure><p>然后输入内网IP:631进入管理页面并登陆</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202302041448968.png" alt=""></p><p>选择usb的打印机即可，其他选项看自己，驱动需要选择对应的，别忘了开启share选项（包括截图页面的）</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202302041450041.png" alt=""></p><p>测试一下，打印成功</p>]]></content>
    
    
    <summary type="html">0x00写在前面
去年暑假组了一台新电脑，老电脑逐渐用不上用场了。恰好我有刷pt的需求，还想运行MC等游戏的服务器，于是我就动手改造这台老电脑了。

0x01硬件配置


这台老电脑是15年配的：CPU是i3-4160，两个核心四个线程；主板是技嘉的丐版H81M-D2，有两个内存插槽，最大只支持8G的DDR3内存；主板有三个PCIE接口，一个PCIEx16够宽，两个PCIEx1比较短；还有四个SATA接口；另外主板太老没有HDMI只有VGA接口，除此之外的千兆以太网口没啥好说的

PCIEx16上的亮机卡是GT640 2G，其实就是装系统时候用的；PCIEx1装了个物联网开机模块，因为我要将其</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="linux" scheme="https://picpo.top/tags/linux/"/>
    
    <category term="ubuntu" scheme="https://picpo.top/tags/ubuntu/"/>
    
    <category term="Docker" scheme="https://picpo.top/tags/Docker/"/>
    
    <category term="NAS" scheme="https://picpo.top/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>shell备份脚本</title>
    <link href="https://picpo.top/2023/01/13/shell%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC/"/>
    <id>https://picpo.top/2023/01/13/shell%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC/</id>
    <published>2023-01-13T15:30:53.000Z</published>
    <updated>2024-09-16T18:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202301132338163.png" alt=""></p><p>写了个shell的备份脚本，自带删除过早存档的功能。</p><p>本意是为饥荒服务器写的，虽然饥荒自带回档，但是人物数据、token以及mod配置没被备份。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line">today=`date +%Y%m%d%H%M`</span><br><span class="line">tar -czvf /mnt/WDC/dst_backup/$today.tar.gz /home/picpo/.klei/DoNotStarveTogether/Cluster_1</span><br><span class="line">find /mnt/WDC/dst_backup/ -type f -mtime +1 -exec rm -f &#123;&#125; \; #自动删除+1是两天之前的存档</span><br><span class="line">echo &quot;backup!$today&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">写了个shell的备份脚本，自带删除过早存档的功能。

本意是为饥荒服务器写的，虽然饥荒自带回档，但是人物数据、token以及mod配置没被备份。

1
2
3
4
5


#! /bin/bash
today=`date +%Y%m%d%H%M`
tar -czvf /mnt/WDC/dst_backup/$today.tar.gz /home/picpo/.klei/DoNotStarveTogether/Cluster_1
find /mnt/WDC/dst_backup/ -type f -mtime +1 -exec rm -f {} &#92;; #自动删除+1是两天之前的存档
echo </summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="linux" scheme="https://picpo.top/tags/linux/"/>
    
    <category term="shell" scheme="https://picpo.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>《汇编语言程序设计》求生指南</title>
    <link href="https://picpo.top/2022/11/14/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97/"/>
    <id>https://picpo.top/2022/11/14/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97/</id>
    <published>2022-11-14T07:26:05.000Z</published>
    <updated>2022-12-28T12:05:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/%E5%9B%BE%E7%89%87-300x181.png" alt=""></p><h2 id="第一章">第一章</h2><ol><li>BCD码转换<br>1010—1111是非法BCD码</li><li>真值数和补码数之间的转换<br>正数的补码等于本身，负数的补码等于反码+1</li><li>n位字长的有符号数、无符号数的数值范围<br>设机器数字长=n, 则n位补码数<br>其真值范围为 －2n-1 ～ +2n-1－1<br>无符号数其数值范围为 0 ～ 2n－1</li><li>常用ASCII码范围：<br>0:48<br>A:65<br>a:97<br>(space):32<br>(回车):13</li><li>C标表示进位，O标表示溢出</li><li>冯诺依曼架构：<strong>运算器、控制器、存储器、输入、输出</strong><br>CPU：运算器和控制器</li></ol><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/image.png" alt=""></p><h2 id="第二章">第二章</h2><ol><li>基本结构寄存器的名称、位长和作用<br>通用寄存器: AX, BX, CX, DX, SI（源变址）, DI（目的变址）, BP（基址指针）<br>段寄存器: CS, SS, DS, ES, FS, GS<br>指针寄存器: IP（指令指针）, SP（堆栈指针）<br>标志寄存器: FLAGS<br>15位标志分为两类: 状态标志和控制标志<br>6种状态标志：CF（进位） OF（溢出） ZF（全零） PF（最后一字节1为偶数为1） AF（辅助进位标志） SF（记录最高位的位值）</li><li>80486的工作模式：实地址模式和保护虚拟地址模式<br>80486的三个存贮地址空间：逻辑空间、线性空间和物理空间<br>逻辑地址：即逻辑上的地址，实模式下由“段基地址+段内偏移”组成;保护模式下由“段选择符+段内偏移”组成。<br>线性地址：逻辑地址经分段机制后就成线性地址，它是平坦的;如果不启用分页，那么此线性地址即物理地址。<br>物理地址：线性地址经分页转换后就成了物理地址。<br><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/image-1.png" alt=""></li><li>实地址模式下，物理地址的形成<br><strong>物理地址=段基址*16+偏移地址</strong><br><strong>内存容量=末地址-首地址+1</strong><br><strong>末地址=首地址+（字数-1）*2 末地址</strong></li></ol><h2 id="第三章">第三章</h2><ol><li><p>源程序中的语句类型<br>一个完整的源程序应包含2类语句:<br>指令性语句（符号指令）、指示性语句(伪指令)</p></li><li><p>80486的寻址方式486有3类7种寻址方式<br>立即寻址方式：获得立即数<br>寄存器寻址方式：获得寄存器操作数<br>存储器操作数寻址方式：获得存储器操作数（内存操作数）</p></li><li><p>内存寻址方式 16位寻址规定可使用的寄存器<br>直接寻址<br>寄存器间接寻址 [BX],[BP],[SI],[DI]。段寄存器：[间址寄存器]，某单元的物理地址=段寄存器内容×16+间址寄存器<br>基址寻址 [BX+位移量],[BP＋位移量]。段寄存器:[基址寄存器+位移量]。物理地址=段寄存器内容×16+基址寄存器+位移量<br>变址寻址 [SI+位移量],[DI+位移量]。<br>基址+变址寻址 [BX+SI],[BX+DI],[BP+SI]，[BP+DI]</p></li><li><p>常用伪指令<br>数据字义伪指令 DB DW DD（一字节二字节四字节）<br>等值伪指令 EQU =</p></li><li><p>常用运算符<br>$运算符：当前汇编计数器的值。通常$-地址，可以求长度<br>SEG运算符：获取段的基地址，SEG DATA<br>OFFSET运算符：相对于段首的基地址<br>PTR运算符：修改属性<br><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/image-2.png" alt=""></p></li><li><p>目标程序的生成<br><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/1668425716_POWERPNT_1065x313.png" alt=""></p></li><li><p>16进制数加法及标志位的影响<br><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/1668425885_POWERPNT_1101x202.png" alt="">80486基本指令集<br><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/1668426216_POWERPNT_1132x505.png" alt=""></p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/1668426445_POWERPNT_1002x554.png" alt=""></p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/1668426487_POWERPNT_1014x818.png" alt=""></p></li></ol><h2 id="第四章">第四章</h2><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/image-3-1024x461.png" alt=""></p>]]></content>
    
    
    <summary type="html">第一章
 1. BCD码转换
    1010—1111是非法BCD码
 2. 真值数和补码数之间的转换
    正数的补码等于本身，负数的补码等于反码+1
 3. n位字长的有符号数、无符号数的数值范围
    设机器数字长=n, 则n位补码数
    其真值范围为 －2n-1 ～ +2n-1－1
    无符号数其数值范围为 0 ～ 2n－1
 4. 常用ASCII码范围：
    0:48
    A:65
    a:97
    (space):32
    (回车):13
 5. C标表示进位，O标表示溢出
 6. 冯诺依曼架构：运算器、控制器、存储器、输入、输出
    CPU：</summary>
    
    
    
    <category term="我爱学习" scheme="https://picpo.top/categories/%E6%88%91%E7%88%B1%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="求生指南" scheme="https://picpo.top/tags/%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>《毛泽东思想和中国特色社会主义理论体系概论》求生指南</title>
    <link href="https://picpo.top/2022/11/06/%E3%80%8A%E6%AF%9B%E6%B3%BD%E4%B8%9C%E6%80%9D%E6%83%B3%E5%92%8C%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB%E6%A6%82%E8%AE%BA%E3%80%8B/"/>
    <id>https://picpo.top/2022/11/06/%E3%80%8A%E6%AF%9B%E6%B3%BD%E4%B8%9C%E6%80%9D%E6%83%B3%E5%92%8C%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB%E6%A6%82%E8%AE%BA%E3%80%8B/</id>
    <published>2022-11-06T12:13:34.000Z</published>
    <updated>2022-12-28T12:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/%E5%9B%BE%E7%89%87-300x181.png" alt=""></p><h2 id="考题分布">考题分布</h2><p>单选题10*1分=10分</p><p>名词解释4*5分=20分</p><p>简答题：4*10=40分</p><p>材料分析题：2*15=30分</p><h2 id="名词解释"><strong>名词解释</strong></h2><ol><li>实事求是：实事求是，就是一切从实际出发，理论联系实际，坚持实践中检验真理和发展真理。毛泽东指出：实事就是客观存在的一切事务，是就是客观事物的内部联系，即规律，求就是要求去研究</li><li>群众路线：一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变成群众自觉的行动</li><li>独立自主：坚持独立思考走自己的路，坚定不移地<strong>维护民族独立</strong>、<strong>捍卫国家主权</strong>，把立足点放在依靠自己的力量基础上，同时积极争取外援，开展国际文化经济交流，学习一切国外<strong>对我们有益的先进</strong>事物</li><li>新民主主义革命的总路线：无产阶级领导的，人民大众的，反对<strong>帝国主义，封建主义，官僚资本主义的革命</strong>（三座大山）</li><li>党在过渡时期的总路线：从新中国成立----&gt;社会主义改造基本完成，这是过渡时期。是在相当长的一段时间内逐步实现国家社会主义工业化，并逐渐对农业手工业<strong>资本主义</strong>工商业社会主义改造</li><li>毛泽东思想：是马克思主义中国化<strong>第一个重大理论成果</strong>，是马克思列宁主义<strong>在中国的运用和发展</strong>，是被实践证明的了中国革命与建设的正确理论原则和经验总结，是中国共产党集体智慧结晶，是党必须长期坚持的指导思想</li><li>三步走战略：1987年4月，邓小平提出，10月确定<br>1981—&gt;1990，国民生产总值比1980翻一番，解决温饱问题<br>1991—&gt;20世纪末，再翻一倍，达到小康水平<br>到21世纪中叶，<strong>人均</strong>国民生产总值达到中等发达国家水平，人民生活富裕，基本实现现代化，继续前进</li><li>社会主义初级阶段理论：初级阶段指我国生产力落后、商品经济不发达的条件下建设社会主义必然要经历的阶段，就是从社会主义—&gt;社会主义现代化基本完成的阶段</li><li>一国两制：在祖国统一的前提下，国家主体实行社会主义制度，港澳台保持原有社会制度和生活方式长期不变</li><li>依法治国：广大人民群众在党的领导下，依照宪法和法律法规，通过各种途径和形式管理<strong>国家事务</strong>，管理<strong>经济文化事业</strong>，管理<strong>社会事务</strong>，保证国家各项工作都依法进行，逐步实现社会主义民主的<strong>制度化和法律化</strong>，使这种<strong>制度和法律</strong>不因<strong>领导人的改变</strong>而改变，不因<strong>领导人看法和注意力改变</strong>而改</li></ol><h2 id="简答题">简答题</h2><h3 id="毛泽东思想形成和发展的社会历史条件">毛泽东思想形成和发展的社会历史条件</h3><ol><li>19世纪末20世纪初，世界进入帝国主义和无产阶级革命时代</li><li>十月革命的胜利开启世界无产阶级革命的新时代。他将中国反帝反封建的民主革命，从<strong>旧的世界资产阶级民主革命</strong>的一部分，转变为<strong>新的世界无产阶级社会主义革命</strong>的一部分</li><li>十月革命送来了马克思列宁主义，中国革命有了科学的指导思想</li><li>中国革命胜利后，经历了二次大战后两大阵营的对立斗争，西方国家不仅封锁禁运而且力求和平演变，毛泽东思想便是从这样的社会历史背景下形成发展的</li><li>中国共产党领导人民进行<strong>革命和建设的成功实践</strong>是毛泽东思想形成发展的<strong>实践基础</strong></li></ol><h3 id="毛泽东思想活的灵魂和历史地位">毛泽东思想活的灵魂和历史地位</h3><p>活的灵魂：实事求是，群众路线，独立自主</p><p>历史地位：</p><ol><li>马克思主义中国化的第一个重大理论成果</li><li>是中国革命和建设的科学指南</li><li>是中国共产党和人民的宝贵精神财富</li></ol><h3 id="土地革命、武装斗争、农村革命根据地建设-三者之间的联系">土地革命、武装斗争、农村革命根据地建设 三者之间的联系</h3><ol><li>土地革命是民主革命的主要内容</li><li>武装斗争是中国革命的主要形式，是农村革命根据地建设和土地革命的强有力保证</li><li>农村革命根据地是中国革命的战略阵地，是进行武装斗争和开展土地革命的依托</li><li>党的领导下，实现了<strong>三者的密切结合和有机统一</strong></li></ol><h3 id="新民主主义革命基本纲领">新民主主义革命基本纲领</h3><ol><li>政治：推翻帝国主义和封建主义统治，建立一个以无产阶级领导、工农联盟为基础的、各个革命阶级联合专政的新民主主义的共和国</li><li>经济：没收封建地主的土地归农民，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业</li><li>文化：无产阶级领导的人民大众的<strong>反帝反封建文化</strong>，民族的科学的大众的文化</li></ol><h3 id="新民主主义革命的三大法宝和相互关系">新民主主义革命的三大法宝和相互关系</h3><p>三大法宝：统一战线，武装斗争，党的建设</p><p>相互关系：统一战线和武装斗争中国革命的两个基本特点，是战胜敌人的基本武器。统一战线是实行武装斗争的统一战线，武装斗争是统一战线的中心支柱，党的组织则是掌握这两个武器的英勇战士</p><h3 id="社会主义改造的经验">社会主义改造的经验</h3><ol><li>社会主义工业建设和社会主义改造同时进行</li><li>积极引导，逐步过渡</li><li>和平方法改造</li></ol><h3 id="社会主义-基本-制度确立的重大意义">社会主义**<em>基本</em>**制度确立的重大意义</h3><p>是中国历史上最深刻最伟大的社会变革，为当今中国奠定了制度基础，也为中特社的建立创新提供了重要前提</p><ol><li>极大地提高了<strong>工人阶级和广大劳动人民</strong>的积极性和创造性，极大促进了生产力发展</li><li>使广大人民真正成为国家主人</li><li>使占全球人口四分之一的东方大国进入了社会主义社会，进一步改变了世界政治经济格局，增强了社会主义力量，对世界和平的维护产生了重要影响</li><li>是马克思列宁主义<strong>关于社会主义革命理论</strong>在中国的正确应用和创造性发展的结果，不仅再次证明了马克思列宁主义的真理性，而且以其独特的理论原则和经验总结<strong>丰富和发展了科学社会主义</strong></li></ol><h3 id="党对社会主义建设道路初步探索的重大意义">党对社会主义建设道路初步探索的重大意义</h3><ol><li>巩固和发展了我国的社会主义</li><li>为开创中特社提供了宝贵经验、理论准备、物质基础</li><li>丰富了科学社会主义的理论和实践</li></ol><h3 id="初步探索的经验教训">初步探索的经验教训</h3><ol><li>必须把马克思主义和中国实际相结合，探索符合中国的道路</li><li>必须正确认识社会主义的主要和次要矛盾，集中力量发展生产力</li><li>必须从实际出发，建设速度和规模要与国力相适应，不能急于求成</li><li>必须发展社会主义民主，健全社会主义法制</li><li>坚持党的民主集中制和集体领导制度，加强执政党建设</li><li>必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设</li></ol><h3 id="邓小平理论形成的历史社会条件">邓小平理论形成的历史社会条件</h3><ol><li>时代背景：和平与发展成为时代主题</li><li>历史根据：社会主义建设的经验教训</li><li>现实依据：改革开放和现代化建设</li></ol><h3 id="三步走">三步走</h3><p>同上</p><h3 id="和平统一一国两制的基本内容">和平统一一国两制的基本内容</h3><ol><li>坚持一个中国</li><li>两制并存</li><li>港澳台高度自治</li><li>尽最大努力争取和平统一，但不承诺放弃使用武力</li><li>解决台湾问题，实现祖国完全统一，寄希望于台湾人民</li></ol><h3 id="简述“改革是中国第二次革命”">简述“改革是中国第二次革命”</h3><ol><li>改革是社会主义社会发展的直接动力。社会主义社会的基本矛盾仍然是生产力和生产关系、上层建筑和经济基础之间的矛盾，这些矛盾推动了社会主义社会的发展。在社会主义社会，改革从根本上改变束缚生产力发展的经济体制，促进生产力的发展，从而解决了发展动力的问题</li><li>改革是一次新的革命，不是也不允许否定和抛弃我们建立起来的社会主义基本制度，他是社会主义制度的自我完善和发展</li><li>改革不是一个阶级推翻另一个阶级的革命，也不是原因经济体制的细枝末节修补，而是对体制的根本性变革。他的实质和目标，是要从根本上改变束缚我国生产力发展的经济体制，建立一个充满生机和活力的社会主义新经济体制，同时相应地改革政治体制和其他方面的体制，以实现社会主义现代化</li></ol><h3 id="邓小平理论的历史地位">邓小平理论的历史地位</h3><ol><li>马克思列宁主义、毛泽东思想的<strong>继承与发展</strong></li><li>中特社理论体系的<strong>开篇之作</strong></li><li><strong>改革开放和社会主义现代化建设的科学指南</strong></li></ol><h3 id="三个代表的社会历史条件">三个代表的社会历史条件</h3><ol><li>时代背景：冷战后对国际局势的科学判断的基础上形成的。世界多极化和经济全球化的趋势在曲折中发展，和平与发展仍是时代的主题</li><li>是科学判断党的历史方位和总结历史经验的基础上提出来的</li><li>是在建设中特社伟大实践的基础上形成的。就是对过程中各种出现的实际问题中形成和发展的</li></ol><h3 id="三个代表">三个代表</h3><ol><li>始终代表中国先进生产力的发展要求</li><li>始终代表中国先进文化的前进方向</li><li>始终代表中国最广大人民的根本利益</li></ol><h3 id="科学发展观的的社会历史条件">科学发展观的的社会历史条件</h3><ol><li>是把深刻把握我国基本国情和新的阶段性特征的基础上形成和发展的</li><li>是总结改开特别是十六大以来实践经验的基础上形成和发展的</li><li>是深刻分析国际形势、顺应世界发展趋势、借鉴国外发展经验的基础上形成和发展的</li></ol><h3 id="科学发展观的科学内涵和精神实质">科学发展观的科学内涵和精神实质</h3><p>内涵：</p><ol><li><strong>推动经济发展</strong>是第一要义</li><li><strong>以人为本</strong>是核心立场</li><li><strong>全面协调可持续</strong>是基本要求</li><li><strong>统筹兼顾</strong>是根本方法</li></ol><p>实质：</p><p>解放思想、实事求是、与时俱进、求真务实</p>]]></content>
    
    
    <summary type="html">考题分布
单选题10*1分=10分

名词解释4*5分=20分

简答题：4*10=40分

材料分析题：2*15=30分

名词解释
 1.  实事求是：实事求是，就是一切从实际出发，理论联系实际，坚持实践中检验真理和发展真理。毛泽东指出：实事就是客观存在的一切事务，是就是客观事物的内部联系，即规律，求就是要求去研究
 2.  群众路线：一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变成群众自觉的行动
 3.  独立自主：坚持独立思考走自己的路，坚定不移地维护民族独立、捍卫国家主权，把立足点放在依靠自己的力量基础上，同时积极争取外援，开展国际文化经济交流，学习一切国外对我</summary>
    
    
    
    <category term="我爱学习" scheme="https://picpo.top/categories/%E6%88%91%E7%88%B1%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="求生指南" scheme="https://picpo.top/tags/%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>stable-diffusion-webui的食用方法</title>
    <link href="https://picpo.top/2022/10/08/stable-diffusion-webui%E7%9A%84%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://picpo.top/2022/10/08/stable-diffusion-webui%E7%9A%84%E9%A3%9F%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2022-10-08T11:15:11.000Z</published>
    <updated>2024-09-16T18:34:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252157828.png" alt=""></p><h2 id="0x01-Anaconda安装">0x01 Anaconda安装</h2><p>这个没啥好说的，主要是要记住你的安装路径</p><h2 id="0x02-安装CUDA">0x02 安装CUDA</h2><p>到官网：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://developer.nvidia.com/cuda-downloads?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252158948.png" alt=""></p><h2 id="0x03-安装stable-diffusion-webui">0x03 安装stable-diffusion-webui</h2><h3 id="1-sd-webui">1.sd-webui</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/sd-webui/stable-diffusion-webui.git</span><br></pre></td></tr></table></figure><p>安装后按他所说的在根目录建立<strong>custom-conda-path.txt</strong>，并写上自己的Anaconda根目录</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252158626.png" alt=""></p><p>下载模型文件，放在**\stable-diffusion-webui\models\ldm\stable-diffusion-v1**下</p><p>其实也可以mklink，不过我没试过，因为我的novelaileak文件在下载盘里，下载盘是个远古机械，速度不是很快</p><h3 id="2-另一个更好的web-ui">2.另一个更好的web-ui</h3><p>这个更好，可以过滤一些negative prompt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone  https://github.com/AUTOMATIC1111/stable-diffusion-webui.git</span><br></pre></td></tr></table></figure><p>安装过程过于缓慢，建议先pip安装他的requirements.txt</p><h3 id="3-泄露模型">3.泄露模型</h3><p>我这里用的是novelaileak的，你也可以用其他的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magnet:?xt=urn:btih:5bde442da86265b670a3e5ea3163afad2c6f8ecc&amp;dn=novelaileak&amp;tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&amp;tr=udp%3A%2F%2F9.rarbg.com%3A2810%2Fannounce&amp;tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A6969%2Fannounce&amp;tr=http%3A%2F%2Ftracker.openbittorrent.com%3A80%2Fannounce&amp;tr=udp%3A%2F%2Fopentracker.i2p.rocks%3A6969%2Fannounce</span><br></pre></td></tr></table></figure><p>第二版（125G）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magnet:?xt=urn:btih:a20087e7807f28476dd7b0b2e0174981709d89cd&amp;dn=novelaileakpt2&amp;tr=udp%3a%2f%2ftracker.openbittorrent.com%3a6969%2fannounce&amp;tr=http%3a%2f%2ftracker.openbittorrent.com%3a80%2fannounce&amp;tr=https%3a%2f%2ftracker.nanoha.org%3a443%2fannounce</span><br></pre></td></tr></table></figure><p>今天流出的新版本，效果更好但是空间占用更大</p><h2 id="0x04-食用">0x04 食用</h2><p>到根目录，运行一下webui的cmd，会自动安装环境</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252159861.png" alt=""></p><p>我的GTX1060 6G生成速度不是很快，我这有块Tesla p4，不知道加上去会不会加快点速度</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252159861.png" alt=""></p><p>更多关键词请见：</p><p><a href="https://wiki.installgentoo.com/wiki/Stable_Diffusion#Keywords">https://wiki.installgentoo.com/wiki/Stable_Diffusion#Keywords</a></p><p><a href="https://gelbooru.com/index.php?page=tags&amp;s=list">https://gelbooru.com/index.php?page=tags&amp;s=list</a></p>]]></content>
    
    
    <summary type="html">0x01 Anaconda安装
这个没啥好说的，主要是要记住你的安装路径

0x02 安装CUDA
到官网：

1


https://developer.nvidia.com/cuda-downloads?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local




0x03 安装stable-diffusion-webui
1.sd-webui
1


git clone https://github.com/sd-webui/stable-diffusion-webui.git


安装后</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="AI" scheme="https://picpo.top/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Github代理</title>
    <link href="https://picpo.top/2022/10/08/github%E4%BB%A3%E7%90%86/"/>
    <id>https://picpo.top/2022/10/08/github%E4%BB%A3%E7%90%86/</id>
    <published>2022-10-08T09:35:14.000Z</published>
    <updated>2024-09-16T18:35:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252133062.jpg" alt=""></p><p>clash别忘了开LAN</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy protocol://127.0.0.1:7890</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">clash别忘了开LAN

1


git config --global http.proxy protocol://127.0.0.1:7890</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="git" scheme="https://picpo.top/tags/git/"/>
    
    <category term="github" scheme="https://picpo.top/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>解决Vmware中Ubuntu22.04的vm-tools无法安装的问题</title>
    <link href="https://picpo.top/2022/09/09/%E8%A7%A3%E5%86%B3vmware%E4%B8%ADubuntu22-04%E7%9A%84vm-tools%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://picpo.top/2022/09/09/%E8%A7%A3%E5%86%B3vmware%E4%B8%ADubuntu22-04%E7%9A%84vm-tools%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-09-09T06:20:52.000Z</published>
    <updated>2024-09-16T18:33:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242323435.jpg" alt=""></p><p>谷歌了一下，vm-tools无法安装初步判定是Vmware 的版本对Ubuntu22.04不兼容造成的，安装open-vm-tools可以解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install open-vm-tools</span><br><span class="line">apt install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">谷歌了一下，vm-tools无法安装初步判定是Vmware 的版本对Ubuntu22.04不兼容造成的，安装open-vm-tools可以解决：

1
2


apt install open-vm-tools
apt install open-vm-tools-desktop</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="ubuntu" scheme="https://picpo.top/tags/ubuntu/"/>
    
    <category term="Vmware" scheme="https://picpo.top/tags/Vmware/"/>
    
  </entry>
  
  <entry>
    <title>远程桌面（RDP）的思考</title>
    <link href="https://picpo.top/2022/09/01/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%EF%BC%88rdp%EF%BC%89%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://picpo.top/2022/09/01/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%EF%BC%88rdp%EF%BC%89%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2022-09-01T15:56:35.000Z</published>
    <updated>2025-04-17T09:52:40.029Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242340599.jpg" alt=""></p><h2 id="0x00说在前面">0x00说在前面</h2><p>新学期，在社团活动室组了一台主机。打算开个远程桌面，这样我在宿舍的话，也可以访问我的主机了。</p><h2 id="0x01方案选择">0x01方案选择</h2><p>无非就以下几个方案：</p><ol><li>第三方远程桌面软件/穿透软件来突破内网限制。这个的话属实没有必要，因为我就在学校里有这个需求，否定。</li><li>IPv4+端口映射。想啥呢，暴露在校园网下，这是要给x1c的大哥们冲业绩吗？否定。</li><li>IPv4+proxifier代理。这个方案是我一开始最认可的，当我搭好socks5隧道时发现，我确实可以访问192.*.*.*下的内网设备，包括我的网页服务器，pt下载机，以及别人乱七八糟的服务端API数据库接口Nas啥的，结果轮到我的主机的rdp端口，他就不行了。初步猜测可能和Windows的防火墙策略有关，但是我在网上找了半天没找到和我一样情况的人，少部分人思路和我一样，但是他们似乎没出现这么神奇的现象，否定。</li><li>IPv6。这个方案是肯定可以的——我现在用的就是。学校里有自己的校园网和运营商网络，运营商网络是没法通过DHCP分配IPv6的，但是校园网是可以的。另外，社团的网也是可以的。</li></ol><p>IPv6的方案好就好在，我校的校园网虽然晚上会断网，但是校园网可以在未登录的情况下分配一个教育网段的地址。就算这个不行，也可以通过连接手机热点的方式，获取IPv6。注意，我校校园网不支持SLACC，安卓设备无法通过连接校园网WiFi来获取v6地址。</p><p>至于客户端，我在Windows端选择的是mstsc（就是专业版自带的那个）。安卓用的是谷歌商店的RD客户端（同样微软出品）。注意，这个软件微软商店也有，但是不推荐，因为延迟远不如原生的mstsc。</p><h2 id="0x02实测表现">0x02实测表现</h2><p>总的来说还是非常不错的，44ms。其实这是最高延迟了，测到过26ms的。</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242340193.png" alt=""></p><h2 id="0x03优化">0x03优化</h2><h3 id="1-突破30fps限制">1.突破30fps限制</h3><p>打开Windows<code>注册表编辑器 (regedit.exe)</code>，找到以下子项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations</span><br></pre></td></tr></table></figure><p>右击新建一个<code>DWORD(32-bit)值</code>的项，改名为<code>DWMFRAMEINTERVAL</code>，修改为十进制下的15。</p><p>为什么？因为这个时候的帧率限制为1000/15，也就是66FPS。</p><p>结束后保存重启，可以远程桌面登录后，通过一些测试fps的网站来测试，你会发现fps不是之前30而是60或者更高了。</p><h3 id="2-显卡加速">2.显卡加速</h3><p>打开远程主机上的组策略（Win+R打开运行，输入<code>gpedit.msc</code>）</p><p>依次找到计算机配置-&gt;管理模板-&gt;Windows组件-&gt;远程桌面服务-&gt;远程桌面会话主机-&gt;远程会话环境</p><p>在右边选择<strong>将硬件图形适配器应用于所有远程桌面服务会话</strong></p><p>同时也可以打开<strong>配置远程桌面连接的H.264/AVC硬件编码</strong></p><p>其实这没啥太大用处，具体原因接着说。</p><h2 id="0x04游戏玩家的十字路口">0x04游戏玩家的十字路口</h2><p>首先我们要明白：<strong>微软RDP是不支持独显的。有需要远程玩游戏的话，需要第三方的远程桌面、远程遥控软件才行。</strong></p><p>在我们连接到远程桌面时，打开任务管理器，会发现独显是可以正常显示的。但是这并不代表你可以打游戏或者开blender啥的。那么这是怎么回事呢？</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242341801.png" alt=""></p><p>如果你在这时打开游戏，你会发现一些游戏确实可以打开。比如我打开文明6，帧率只有30+，cpu频率暴增到3.99GHz，占用暴增40%，显卡摆烂在3%一动不动，这和在本机打开后的表现天差地别。而像apex，那就根本打不开了。注意，这和有无集显没有关系，我是12400F，照样可以显示，说明是有个虚拟显卡的。</p><p>当然，NVidia也注意到了这一点，于是推出了nvidia-opengl-rdp——恕我直言，这个驱动几乎没什么作用……都什么年代了，还在用传统OpenGL。DirectX有人说是原生支持了，我觉得他在放屁，要是真的原生支持我怎么可能出现以上情况？</p><p>官网下载需要登陆注册developer账号，我找到个第三方的百度网盘下载，不大就0.3M大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1HKy\_Q\_rZx1oy3kq4XO0AuA  </span><br><span class="line">提取码：pntw</span><br></pre></td></tr></table></figure><p>至于想玩游戏嘛……可以试试其他的软件，可能在延迟方面不如微软原生的mstsc，也有是游戏识别的限制。这些东西，等我以后试到了再做反馈吧。</p>]]></content>
    
    
    <summary type="html">0x00说在前面
新学期，在社团活动室组了一台主机。打算开个远程桌面，这样我在宿舍的话，也可以访问我的主机了。

0x01方案选择
无非就以下几个方案：

 1. 第三方远程桌面软件/穿透软件来突破内网限制。这个的话属实没有必要，因为我就在学校里有这个需求，否定。
 2. IPv4+端口映射。想啥呢，暴露在校园网下，这是要给x1c的大哥们冲业绩吗？否定。
 3. IPv4+proxifier代理。这个方案是我一开始最认可的，当我搭好socks5隧道时发现，我确实可以访问192.*.*.*下的内网设备，包括我的网页服务器，pt下载机，以及别人乱七八糟的服务端API数据库接口Nas啥的，结果轮到我</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="RDP" scheme="https://picpo.top/tags/RDP/"/>
    
  </entry>
  
  <entry>
    <title>记一次文件上传类型渗透</title>
    <link href="https://picpo.top/2022/05/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%B1%BB%E5%9E%8B%E6%B8%97%E9%80%8F/"/>
    <id>https://picpo.top/2022/05/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%B1%BB%E5%9E%8B%E6%B8%97%E9%80%8F/</id>
    <published>2022-05-07T08:50:41.000Z</published>
    <updated>2024-09-16T18:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252151241.jpg" alt=""></p><p>仅用于信息安全教学和演示，请勿用于其他用途</p><blockquote><p>“从未如此美妙的开局！”</p></blockquote><h2 id="0x00写在前面">0x00写在前面</h2><p>很久没有做安全相关的事了，昨天在好奇心的驱使下，尝试挖了一个比较简单的洞，过程不复杂，但是对于以后的可能进行的后端开发敲响了警钟。</p><h2 id="0x01过程"><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252151117.png" alt="">0x01过程</h2><p>这个网站是一个某类表情包（一眼丁真）的分享网站，有随机表情包、按照id搜索表情包、按照id点赞表情包、上传表情包等功能。显然，有上传就一定有审核，有审核就一定有管理员端，而且这是肯定进不去的。（下图为按照id点赞表情包的api，没啥用其实）</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252152233.png" alt=""></p><p>还是看看他的主界面吧，有一个上传，看看源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;upload-pic-box&quot;&gt;</span><br><span class="line">    &lt;a id=&quot;pic-path&quot;&gt;上传一张图片吧&lt;/a&gt;</span><br><span class="line">    &lt;form id=&quot;upload-form&quot;&gt;</span><br><span class="line">        &lt;input onchange=&quot;validateFileType()&quot; type=&quot;file&quot; accept=&quot;image/gif,image/jpeg,image/jpg,image/png,image/svg&quot; name=&quot;user-upload&quot; id=&quot;user-upload&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//...此处省略114514行~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    var fileName = document.getElementById(&quot;user-upload&quot;).value;</span><br><span class="line">    var extFile = fileName.substr(idxDot, fileName.length).toLowerCase();</span><br><span class="line">    if (extFile == &quot;jpg&quot;  extFile == &quot;jpeg&quot;  extFile == &quot;png&quot;  extFile == &#x27;gif&#x27;) &#123;</span><br><span class="line">        showfilename();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        alert(&quot;你怎么骗我，\n哼，上传点正常格式的照片！（jpg/png/gif）&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果服务端没做验证的话，这里的前端校验就是马奇诺防线，轻松上传我们的🐴</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252152111.png" alt=""></p><p>然后我们需要定位我们的🐴在哪里了，本来这有些棘手，毕竟万一人家后端有个杀🐴程序呢？（虽然能上传成功的话就说明大概率不会有了233）</p><p>然鹅，在审查其他api时，我发现了有个叫做/admin-get.php的get请求。我试着直接curl了一下，结果大跌眼镜的是，这玩意谁都能访问，而且一堆较为敏感的信息，虽然没有标识，但是能一眼看出有些字段是图片id和<strong>图片地址</strong>的。这极为致命，因为这就告诉了我上传的🐴的位置。</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252152329.png" alt=""></p><p>这就离谱了嗷xdm，让我们连一下蚁剑</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252152852.png" alt=""></p><p><img src="http://192.168.1.35/wp-content/uploads/2022/05/%E5%9B%BE%E7%89%87-7-1024x168.png" alt=""></p><p>xswl</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252152256.png" alt=""></p><p>不过还是要提issue的，这是道德底线</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252152256.png" alt=""></p><p>作者也在后面做了补救措施，看得出来还是个比较核善的人😋😋😋</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252153180.png" alt=""></p><h2 id="0x02后记">0x02后记</h2><p>实际上，我一直是在做黑盒测试，我是在拿到shell后才注意到它原来本身就开源了（离谱，那我浪费时间干嘛）。</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212252153366.png" alt=""></p><p>可以看出来作者本人真的强，但是再强的人也难免有些地方不如成熟框架做的细致。想起我这种彩笔以前直接用几个组件拼接了一个后端，还自以为是地写了个恶心人的黑盒，就以为能抵御95%的入侵了，结果某个“阿喀琉斯之踵”被别人（plusls）拒绝服务攻击了，寄。</p>]]></content>
    
    
    <summary type="html">仅用于信息安全教学和演示，请勿用于其他用途

“从未如此美妙的开局！”

0x00写在前面
很久没有做安全相关的事了，昨天在好奇心的驱使下，尝试挖了一个比较简单的洞，过程不复杂，但是对于以后的可能进行的后端开发敲响了警钟。

0x01过程
这个网站是一个某类表情包（一眼丁真）的分享网站，有随机表情包、按照id搜索表情包、按照id点赞表情包、上传表情包等功能。显然，有上传就一定有审核，有审核就一定有管理员端，而且这是肯定进不去的。（下图为按照id点赞表情包的api，没啥用其实）



还是看看他的主界面吧，有一个上传，看看源码

1
2
3
4
5
6
7
8
9
10
11
12
13
14
</summary>
    
    
    
    <category term="安全" scheme="https://picpo.top/categories/%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="PHP" scheme="https://picpo.top/tags/PHP/"/>
    
    <category term="文件上传" scheme="https://picpo.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>青年大学习（江苏）的HTTP请求分析</title>
    <link href="https://picpo.top/2022/04/05/%E9%9D%92%E5%B9%B4%E5%A4%A7%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%B1%9F%E8%8B%8F%EF%BC%89%E7%9A%84http%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <id>https://picpo.top/2022/04/05/%E9%9D%92%E5%B9%B4%E5%A4%A7%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%B1%9F%E8%8B%8F%EF%BC%89%E7%9A%84http%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/</id>
    <published>2022-04-05T06:20:35.000Z</published>
    <updated>2024-09-16T18:32:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242318378.png" alt=""></p><h2 id="0x01抓包">0x01抓包</h2><p>江苏省青年大学习的接口：<a href="https://service.jiangsugqt.org/youth/lesson">https://service.jiangsugqt.org/youth/lesson</a></p><p><strong>确认课程</strong>的接口：<a href="https://service.jiangsugqt.org/youth/lesson/confirm">https://service.jiangsugqt.org/youth/lesson/confirm</a></p><p>微信打开xweb调试界面，打开就行：<a href="http://debugxweb.qq.com/?inspector=true">http://debugxweb.qq.com/?inspector=true</a></p><h2 id="0x02获取cookie">0x02获取cookie</h2><p>青年大学习是通过cookie中的laravel_session来获取用户信息的，现在微信早就不支持vconsole了（要是支持我还这么抓包干嘛？），需要手机usb连接电脑，用Google chrome（建议edge浏览器，Google的有些资源加载不出来，或者很慢）的chrome://inspect/#devices里面进行调试</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242319220.png" alt=""></p><h2 id="0x03发送请求">0x03发送请求</h2><p>我们只要发送两个请求，一个是江苏省青年大学习的接口，还有一个是<strong>确认课程</strong>的接口。</p><p>江苏省青年大学习的接口是用于获取课程信息的，里面能解析到下一个接口所需的_token和lesson_id字段</p><p>然后就是发post请求啦</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242320313.png" alt=""></p>]]></content>
    
    
    <summary type="html">0x01抓包
江苏省青年大学习的接口：https://service.jiangsugqt.org/youth/lesson

确认课程的接口：https://service.jiangsugqt.org/youth/lesson/confirm

微信打开xweb调试界面，打开就行：http://debugxweb.qq.com/?inspector=true

0x02获取cookie
青年大学习是通过cookie中的laravel_session来获取用户信息的，现在微信早就不支持vconsole了（要是支持我还这么抓包干嘛？），需要手机usb连接电脑，用Google chrome（建议</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="HTTP" scheme="https://picpo.top/tags/HTTP/"/>
    
    <category term="青年大学习" scheme="https://picpo.top/tags/%E9%9D%92%E5%B9%B4%E5%A4%A7%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>git cz和合乎Angular规范的git commit message</title>
    <link href="https://picpo.top/2022/02/13/git-cz%E5%92%8C%E5%90%88%E4%B9%8Eangular%E8%A7%84%E8%8C%83%E7%9A%84git-commit-message/"/>
    <id>https://picpo.top/2022/02/13/git-cz%E5%92%8C%E5%90%88%E4%B9%8Eangular%E8%A7%84%E8%8C%83%E7%9A%84git-commit-message/</id>
    <published>2022-02-13T10:20:22.000Z</published>
    <updated>2024-09-16T18:35:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242334513.jpg" alt=""></p><h2 id="配置git-cz">配置git cz</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g commitizen</span><br></pre></td></tr></table></figure><h2 id="使用git-cz">使用git cz</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git cz</span><br><span class="line"></span><br><span class="line">cz-cli@4.1.2, cz-conventional-changelog@3.2.0</span><br><span class="line"></span><br><span class="line">#指定commit的类型，约定了feat、fix两个主要type，以及docs、style、build、refactor、revert五个特殊type</span><br><span class="line">? **Select the type of change that you&#x27;re committing:** fix:   A bug fix</span><br><span class="line"></span><br><span class="line">#用于描述改动的范围，格式为项目名/模块名</span><br><span class="line">? **What is the scope of this change (e.g. component or file name): (press enter t**</span><br><span class="line">**o skip)** index.html</span><br><span class="line"></span><br><span class="line">#对改动进行简短的描述</span><br><span class="line">? **Write a short, imperative tense description of the change (max 83 chars):**</span><br><span class="line"> (11) add a blank</span><br><span class="line"></span><br><span class="line">#对改动进行长的描述</span><br><span class="line">? **Provide a longer description of the change: (press enter to skip)**</span><br><span class="line"></span><br><span class="line">#是破坏性的改动吗</span><br><span class="line">? **Are there any breaking changes?** No</span><br><span class="line"></span><br><span class="line">#影响了哪个issue吗，如果选是，接下来要输入issue号</span><br><span class="line">? **Does this change affect any open issues?** No</span><br></pre></td></tr></table></figure><h2 id="Angular规范">Angular规范</h2><h3 id="Header">Header</h3><h4 id="（1）type"><strong>（1）type</strong></h4><p><code>type</code> 用于说明 commit 的类别，只允许使用下面 7 个标识。</p><ul><li>feat：新功能（feature）</li><li>fix：修补 bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改 bug 的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><p>如果 <code>type</code> 为 <code>feat</code> 和 <code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</p><h4 id="（2）scope"><strong>（2）scope</strong></h4><p><code>scope</code> 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><h4 id="（3）subject"><strong>（3）subject</strong></h4><p><code>subject</code> 是 commit 目的的简短描述，不超过 50 个字符。</p><ul><li>以动词开头，使用第一人称现在时，比如 <code>change</code>，而不是 <code>changed</code> 或 <code>changes</code></li><li>第一个字母小写</li><li>结尾不加句号（<code>.</code>）</li></ul><h3 id="Body">Body</h3><p>有两个注意点。</p><p>（1）使用第一人称现在时，比如使用 <code>change</code> 而不是 <code>changed</code> 或 <code>changes</code>。</p><p>（2）应该说明代码变动的动机，以及与以前行为的对比。</p><h3 id="Footer">Footer</h3><p>Footer 部分只用于两种情况。</p><h4 id="（1）不兼容变动"><strong>（1）不兼容变动</strong></h4><p>如果当前代码与上一个版本不兼容，则 Footer 部分以 <code>BREAKING CHANGE</code> 开头，后面是对变动的描述、以及变动理由和迁移方法。</p><h4 id="（2）关闭-Issue"><strong>（2）关闭 Issue</strong></h4><p>如果当前 commit 针对某个 issue，那么可以在 Footer 部分关闭这个 issue 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #234</span><br></pre></td></tr></table></figure><p>也可以一次关闭多个 issue 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closes #123, #245, #992</span><br></pre></td></tr></table></figure><h3 id="Revert">Revert</h3><p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以 <code>revert:</code> 开头，后面跟着被撤销 Commit 的 Header。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &#x27;graphiteWidth&#x27; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body 部分的格式是固定的，必须写成 <code>This reverts commit &lt;hash&gt;.</code>，其中的 <code>hash</code> 是被撤销 commit 的 SHA 标识符。</p><p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的 <code>Reverts</code> 小标题下面。</p>]]></content>
    
    
    <summary type="html">配置git cz
1


npm install -g commitizen


使用git cz
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23


git cz

cz-cli@4.1.2, cz-conventional-changelog@3.2.0

#指定commit的类型，约定了feat、fix两个主要type，以及docs、style、build、refactor、revert五个特殊type
? **Select the type of change that you&#39;re committing:** f</summary>
    
    
    
    <category term="野生技术协会" scheme="https://picpo.top/categories/%E9%87%8E%E7%94%9F%E6%8A%80%E6%9C%AF%E5%8D%8F%E4%BC%9A/"/>
    
    
    <category term="Angular" scheme="https://picpo.top/tags/Angular/"/>
    
    <category term="git" scheme="https://picpo.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构》速通指南</title>
    <link href="https://picpo.top/2022/01/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%9F%E9%80%9A%E6%8C%87%E5%8D%97/"/>
    <id>https://picpo.top/2022/01/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%9F%E9%80%9A%E6%8C%87%E5%8D%97/</id>
    <published>2022-01-19T03:18:28.000Z</published>
    <updated>2024-09-17T07:06:49.261Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/47e40fdca144ad3462e305e3dea20cf430ad85bb.jpg" alt=""></p><h2 id="感受">感受</h2><p>考试感觉有手就行，20分钟写完，结果就96，乐</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242304547.png" alt=""></p><h2 id="绪论">绪论</h2><h3 id="逻辑结构">逻辑结构</h3><p>1. 线性结构 1:1<br>2. 树形结构 1:n<br>3. 图结构 m:n<br>4. 集合结构 没啥关系</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/%E5%9B%BE%E7%89%87-50.png" alt=""></p><p>分成两类：线性数据结构与非线性数据结构（废话）</p><h3 id="存储结构">存储结构</h3><p>1. 顺序存储结构 依次存储<br>2. 链式存储结构 连续的或不连续的存储空间</p><h3 id="算法时间复杂度">算法时间复杂度</h3><p>$$O\left(1\right)&lt;O\left(\log_2n\right)&lt;O\left(n\right)&lt;O\left(n\log_2n\right)&lt;O\left(n^2\right)&lt;O\left(n^3\right)&lt;O\left(n!\right)&lt;O\left(n^n\right)$$</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">...</span><br><span class="line">i=k*i;</span><br><span class="line">&#125;while(i&lt;=n)</span><br></pre></td></tr></table></figure><p>时间复杂度：$O\left(\log_kn\right)$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while(n&gt;=f(y))</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O\left(f^{-1}\left(n\right)\right)$</p><h2 id="线性表">线性表</h2><h3 id="顺序存储结构">顺序存储结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct seqList</span><br><span class="line">&#123;</span><br><span class="line">int n; // 元素个数</span><br><span class="line">int maxLength; // 最大长度</span><br><span class="line">ElemType *element; // 数组头指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://192.168.1.35/wp-content/uploads/2022/01/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt=""></p><p>插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status Insert(SeqList *L, int i, ElemType x) //L:线性表 i:待插入下标 x:待插入元素</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    if(i &lt; -1  i &gt; L-&gt;n-1) //下标i越界</span><br><span class="line">        return ERROR;</span><br><span class="line">    if(L-&gt;n == L-&gt;maxLength) //顺序表存储空间已满</span><br><span class="line">        return ERROR;</span><br><span class="line">    for(j = L-&gt;n-1 ; j&gt;i ;j--)</span><br><span class="line">        L-&gt;element[j+1] = L-&gt;element[j]; //从后往前逐个后移</span><br><span class="line">    L-&gt;element[i+1] = x; //新元素插入</span><br><span class="line">    L-&gt;n++; //元素个数+1</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$ O\left(n\right) $</p><p>删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status Delete(SeqList *L, int i) //L:线性表 i:待删除下标</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    if(i &lt; -1  i &gt; L-&gt;n-1) //下标i越界</span><br><span class="line">        return ERROR;</span><br><span class="line">    if(!L-&gt;n) //顺序表为空</span><br><span class="line">        return ERROR;</span><br><span class="line">    for(j=i+1 ; j &lt; L-&gt;n ;j++) </span><br><span class="line">        L-&gt;element[j-1] = L-&gt;element[j]; //从前往后逐个前移</span><br><span class="line">    L-&gt;n--; //元素个数-1</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$ O\left(n\right) $</p><p>查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status Find(SeqList L,int i,Element *x)</span><br><span class="line">&#123;</span><br><span class="line">    if(i&lt;0  i &gt; L.n-1)</span><br><span class="line">        return ERROR;</span><br><span class="line">    *x = L.element[i];</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$ O\left(1\right) $</p><h3 id="单链表">单链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">ElemType element ; //结点的数据域</span><br><span class="line">struct node *link;//结点的指针域</span><br><span class="line">&#125;Node;</span><br><span class="line">typedef struct singleList</span><br><span class="line">&#123;</span><br><span class="line">struct node *first; // 表头结点</span><br><span class="line">int n; // 元素个数</span><br><span class="line">&#125;SingleList;</span><br></pre></td></tr></table></figure><p><img src="http://192.168.1.35/wp-content/uploads/2022/01/%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt=""></p><p>插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Status Insert(SingleList *L, int i, ElemType x) //L:线性表地址 i:插入下标 x:插入值</span><br><span class="line">&#123;</span><br><span class="line">    Node *p, *q;</span><br><span class="line">    int j;</span><br><span class="line">    if(i&lt;-1  i &gt; L-&gt;n-1) // i越界</span><br><span class="line">        return ERROR;</span><br><span class="line">    p = L-&gt;first; </span><br><span class="line">    for(j=0 ; j&lt;i ;j++) //p从头结点开始遍历</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    q = malloc(sizeof(Node)); //给待插入结点申请空间</span><br><span class="line">    q-&gt;element = x; // 待插入结点数据域赋值</span><br><span class="line">    </span><br><span class="line">    if(i&gt;0) // 插入位置不是头结点</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;link = p-&gt;link; // q指针指向p下一个结点</span><br><span class="line">        p-&gt;link = q;  // p结点指针指向q</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;link = L-&gt;first; // q指针指向原头结点</span><br><span class="line">        L-&gt;first = q; // L头结点变为q</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    L-&gt;n++; // 表长++</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Status Delete(SingleList *L, int i) //L:线性表地址 i:待删除下标</span><br><span class="line">&#123;</span><br><span class="line">    Node *p,*q;</span><br><span class="line">    int j;</span><br><span class="line">    if(i&lt;0  i &gt; L-&gt;n-1)  // i越界</span><br><span class="line">        return ERROR;</span><br><span class="line">    if(!L-&gt;n) // 链式表为空</span><br><span class="line">        return ERROR;</span><br><span class="line">    p = L-&gt;first;</span><br><span class="line">    for(j=0 ; j &lt; i - 1 ; j++) //p 遍历到待删除位置</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    </span><br><span class="line">    if(i==0) // 删除的是头结点</span><br><span class="line">        L-&gt;first = L-&gt;first-&gt;link; //L头结点为原头结点指针指向的结点</span><br><span class="line">    else //正常的结点</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;link; //q为p所指向的结点</span><br><span class="line">        p-&gt;link = q-&gt;link; // p指针指向结点为q指针指向的结点</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(q); // 释放被删除q的空间</span><br><span class="line">    L-&gt;n--; // L元素个数-1</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status Find(SingleList L, int i, Elemtype *x)</span><br><span class="line">&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    int j;</span><br><span class="line">    if(i&lt;0  i&gt;L.n-1) // i越界</span><br><span class="line">        return ERROR;</span><br><span class="line">    p = L.first;</span><br><span class="line">    for(j=0 ; j&lt;i ;j++) // p从头遍历</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    *x = p-&gt;element; // x赋值</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带表头单链表">带表头单链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct headerList</span><br><span class="line">&#123;</span><br><span class="line">    struct Node *head; //定义表头</span><br><span class="line">    int n; //元素个数</span><br><span class="line">&#125;HeaderList;</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Init(HeaderList *L)&#123;</span><br><span class="line">    L-&gt;head=(Node*)malloc(sizeof(Node));</span><br><span class="line">    L-&gt;head-&gt;link=NULL;</span><br><span class="line">    L-&gt;n=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（单）循环链表">（单）循环链表</h3><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242305682.png" alt=""></p><p>也可以带表头</p><h3 id="双向链表">双向链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    ElemType element; // 数据域</span><br><span class="line">    struct Node *llink; //左指针域</span><br><span class="line">    struct Node *rlink; //右指针域</span><br><span class="line">&#125;DuNode,DuList;</span><br></pre></td></tr></table></figure><p><img src="http://192.168.1.35/wp-content/uploads/2022/02/%E5%9B%BE%E7%89%87-1.png" alt=""></p><p>插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;llink = p-&gt;llink; // q左指针指向p左指针指向的结点</span><br><span class="line">q-&gt;rlink = p; // q右指针指向p结点</span><br><span class="line">p-&gt;llink-&gt;rlink = q; // p左指针指向的结点(即p原左结点)右指针指向q结点</span><br><span class="line">p-&gt;llink = q; // p左指针指向q</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200822050054244.gif#pic_center" alt="双向链表插入"></p><p>删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;llink-&gt;rlink = p-&gt;rlink; // p的左结点直接指向p的右结点</span><br><span class="line">p-&gt;rlink-&gt;llink = p-&gt;llink; // p的右结点直接指向p的左结点</span><br><span class="line">free(p); // 释放p</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200822050054393.gif#pic_center" alt="双向链表删除"></p><h3 id="线性表优劣比较">线性表优劣比较</h3><p>顺序表</p><p>单链表</p><p>带表头的链表</p><p>循环链表</p><p>双向链表</p><p>优</p><p>查找速度$$O(1)$$</p><p>确定位置后，增删速度$$O(1)$$ 不需要估计存储长度</p><p>方便插入和删除操作的实现</p><p>从表中任意结点出发都能扫描整个链表</p><p>可快速访问直接前驱</p><p>劣</p><p>增删速度$$O(n)$$ 需要先估计存储空间</p><p>查找速度$$O(n)$$ 增删中头结点需要单独考虑</p><h2 id="栈堆和队列">栈堆和队列</h2><h3 id="栈堆">栈堆</h3><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242305945.png" alt=""></p><p>共有$$f(n)=\dfrac{C^n_{2n}}{n+1}$$种出栈顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">typedef struct stack</span><br><span class="line">&#123;</span><br><span class="line">    int top; // 栈顶位置下标，空栈为-1</span><br><span class="line">    int maxSize; // 栈最大容量</span><br><span class="line">    ElemType *element; //栈数组首地址</span><br><span class="line">&#125;</span><br><span class="line">//创建</span><br><span class="line">void Create(Stack *S, int mSize) //S:栈地址 mSize:最大容量</span><br><span class="line">&#123;</span><br><span class="line">S-&gt;maxSize = mSize; //获取最大容量</span><br><span class="line">S-&gt;element = (ElemType*)malloc(sizeof(ElemType)*mSize); //给栈申请空间</span><br><span class="line">S-&gt;top=-1; //栈顶为负</span><br><span class="line">&#125;</span><br><span class="line">//销毁</span><br><span class="line">void Destroy(Stack *S)</span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;maxSize = -1; //容量为负</span><br><span class="line">    free(S-&gt;element); //释放栈数组</span><br><span class="line">    S-&gt;top = -1; //栈顶为负</span><br><span class="line">&#125;</span><br><span class="line">//销毁不释放</span><br><span class="line">void Clear(Stack *S)</span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;top = -1; //仅仅将栈顶归负</span><br><span class="line">&#125;</span><br><span class="line">//取栈顶元素</span><br><span class="line">BOOL Top(Stack *S, ElemType *x)</span><br><span class="line">&#123;</span><br><span class="line">    if(IsEmpty(S)) //空栈</span><br><span class="line">        return ERROR；</span><br><span class="line">    *x = S-&gt;element[S-&gt;top]; //取栈顶</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- 满栈——S-&gt;top == S-&gt;maxSize-1</span><br><span class="line">- 空栈——S-&gt;top == -1</span><br><span class="line"></span><br><span class="line">//入</span><br><span class="line">BOOL Push(Stack *S, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    if(IsFull(S)) // 溢出</span><br><span class="line">        return FALSE;</span><br><span class="line">    S-&gt;top++; //栈顶上移</span><br><span class="line">    S-&gt;element[S-&gt;top] = x; //栈顶取值</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">//出</span><br><span class="line">BOOL Pop(Stack *S)</span><br><span class="line">&#123;</span><br><span class="line">    if(IsEmpty(S)) //空栈</span><br><span class="line">        return TRUE;</span><br><span class="line">    S-&gt;top--; //栈顶下移</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列">队列</h3><p>注意：教材给的a0没有数据，front所在为空，所以实际存储量maxsize-1</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242306641.png" alt=""></p><ul><li>空队列——<code>front == rear</code></li><li>满队列——<code>(rear+1) % maxSize == font</code></li><li>队尾进1（入队）——<code>rear = (rear+1) % maxSize</code></li><li>队头进1（出队）——<code>front = (front+1) % maxSize</code></li></ul><p>会假溢出，所以还是用循环队列</p><h3 id="循环队列">循环队列</h3><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242306355.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">typedef struct queue</span><br><span class="line">&#123;</span><br><span class="line">    int front; //队头位置</span><br><span class="line">    int rear; //队尾位置</span><br><span class="line">    int maxSize; //队列容量</span><br><span class="line">    ElemType *element; // 队列数组首地址</span><br><span class="line">&#125;Queue;</span><br><span class="line">//创建</span><br><span class="line">void Create(Queue *Q, int mSize) //Q:队列首地址 mSize:最大容量</span><br><span class="line">&#123;</span><br><span class="line">    Q-&gt;maxSize = mSize; // 最大容量赋值</span><br><span class="line">    Q-&gt;element = (ElemType*)malloc(sizeof(ElemType)*mSize); // 为队列数组申请空间</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = 0; // 队头队尾归零</span><br><span class="line">&#125;</span><br><span class="line">//销毁</span><br><span class="line">void Destroy(Queue *Q)</span><br><span class="line">&#123;</span><br><span class="line">    free(Q-&gt;element); //释放数组空间</span><br><span class="line">    Q-&gt;maxSizw = -1; //最大容积归负</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = -1; //队头队尾归负</span><br><span class="line">&#125;</span><br><span class="line">//销毁不释放</span><br><span class="line">void Clear(Queue *Q)</span><br><span class="line">&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = 0; // 队头队尾归零</span><br><span class="line">&#125;</span><br><span class="line">//获取队头</span><br><span class="line">BOOL Front(Queue *Q, ElemType *x)</span><br><span class="line">&#123;</span><br><span class="line">    if(IsEmpty(Q)) // 空队列</span><br><span class="line">        return FALSE;</span><br><span class="line">    *x = Q-&gt;element[(Q-&gt;front+1) % Q-&gt;maxSize]; // 取队头元素</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">//入</span><br><span class="line">BOOL EnQueue(Queue *Q, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    if(IsFull(Q)) // 溢出</span><br><span class="line">        return FALSE;</span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear+1) % Q-&gt;maxSize; // 队尾进1</span><br><span class="line">    Q-&gt;element[Q-&gt;rear] = x; // 队尾赋值</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">//出</span><br><span class="line">BOOL DeQueue(Queue *Q)</span><br><span class="line">&#123;</span><br><span class="line">    if(IsEmpty(Q)) // 空队列</span><br><span class="line">        return FALSE;</span><br><span class="line">    Q-&gt;front = (Q-&gt;front+1) % Q-&gt;maxSize; //队头进1</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式队列">链式队列</h3><p>教材未作重点，但是了解一下</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242306188.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">    Elemtype element; //数据域</span><br><span class="line">    struct node *link; //指针域</span><br><span class="line">&#125;Node;</span><br><span class="line">typedef struct queue</span><br><span class="line">&#123;</span><br><span class="line">    Node *front; //头指针</span><br><span class="line">    Node *rear; //尾指针</span><br><span class="line">&#125;Queue;</span><br><span class="line">//入</span><br><span class="line">void Enqueue(Queue *Q, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    Node *p = (Node*)malloc(sizeof(Node)); // 结点申请空间</span><br><span class="line">    p-&gt;element = x; // 结点赋值</span><br><span class="line">    p-&gt;link = NULL; // 结点指向空</span><br><span class="line">    Q-&gt;rear-&gt;link = p; // 队列尾指向结点</span><br><span class="line">    Q-&gt;rear = p; //结点作为队列尾</span><br><span class="line">&#125;</span><br><span class="line">//出</span><br><span class="line">void DeQueue(Queue *Q)</span><br><span class="line">&#123;</span><br><span class="line">    if(Q-&gt;front == NULL) // 空队列</span><br><span class="line">        return;</span><br><span class="line">    Node *p = Q-&gt;front; //结点p移动到队头</span><br><span class="line">    Q-&gt;front = p-&gt;link; //队头变为结点所指向的结点</span><br><span class="line">    free(p); //释放结点</span><br><span class="line">    </span><br><span class="line">    if(Q-&gt;front == NULL) //若为空队，重置队尾</span><br><span class="line">        Q-&gt;rear = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后缀表达式">后缀表达式</h3><p>应该就考填空</p><p>书上是栈的方法，我们来用这个</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242306960.jpg" alt=""></p><ul><li>先序遍历（先根）是先访问当前节点，然后再遍历左子树，最后是右子树。</li><li>中序遍历（中根）是先遍历左子树，再访问当前节点，最后是右子树。</li><li>后序遍历（后根）是先遍历左子树，再遍历右子树，最后访问当前节点。</li></ul><p>显然，逆波兰表达式为：4 1 5 2 - * + 6 3 / -</p><h2 id="数组和字符串">数组和字符串</h2><h3 id="数组（库）">数组（库）</h3><p>一维数组</p><p>$Loc(a[i]) = Loc(a[0]) + i*k$</p><p>二维数组</p><p><img src="https://img-blog.csdnimg.cn/20200822222819277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="二维数组"></p><p>行优先顺序地址计算</p><p><img src="https://img-blog.csdnimg.cn/20200822222941428.png#pic_center" alt="行优先"></p><p>$$loc(ai)=loc(a0)+(in+j)k$$</p><ul><li>$k$——每个元素存储单位</li><li>$loc(a0)$——第一个元素存储地址</li><li>$loc(ai)$——$ai$存储地址</li></ul><p>列优先</p><p><img src="https://img-blog.csdnimg.cn/20200822223459115.png#pic_center" alt="列优先"></p><p>$loc(ai)=loc(a0)+(jm+i)k$</p><h3 id="数组抽象数据结构（三维数组实现）">数组抽象数据结构（三维数组实现）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">typedef struct tdarray&#123;</span><br><span class="line">    int m1, m2, m3; // 每个维度的值</span><br><span class="line">    int *array; //数组首地址</span><br><span class="line">&#125;TDArray;</span><br><span class="line">//创建</span><br><span class="line">Status CreateArray(TDArray *tdArray, int m1,int m2,int m3)</span><br><span class="line">&#123;</span><br><span class="line">    tdarray-&gt;m1 = m1;</span><br><span class="line">    tdarray-&gt;m2 = m2;</span><br><span class="line">    tdarray-&gt;m3 = m3;</span><br><span class="line">    tdarray-&gt;array = (int*)malloc(m1*m2*m3*sizeof(int));  // 申请空间</span><br><span class="line">    if(!tdarray-&gt;array) //申请失败</span><br><span class="line">        return ERROR;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">//下标检查（返回地址）</span><br><span class="line">Status RetrieveArray(TDArray tdarray,int i1,int i2,int i3,int *x)</span><br><span class="line">&#123;</span><br><span class="line">    if(!tdarray.array)  //数组不存在</span><br><span class="line">        return NotPresent;</span><br><span class="line">    if(i1&lt;0  i2&lt;0  i3&lt;0  i1&gt;tdarray.m1  i1&gt;tdarray.m2  i1&gt;tdarray.m3 ) //越界</span><br><span class="line">        return IllegalIndex;</span><br><span class="line">    *x = *(tdarray.array+i1*tdarray.m2*tdarray.m3+i2*tdarray.m3+i3); // 返回存储位置</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊矩阵">特殊矩阵</h3><p>对称矩阵</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242307676.png" alt=""></p><p>存上三角或者下三角</p><p>下三角矩阵</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242307425.png" alt=""></p><p>上三角矩阵</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242307257.png" alt=""></p><p>0或者其他常数放到最后一个值里面</p><h3 id="稀疏矩阵">稀疏矩阵</h3><p>以三元组$&lt;i,j,a_{ij}&gt;$表示</p><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242307329.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct term</span><br><span class="line">&#123;</span><br><span class="line">    int col,row; // 列下标，行下标</span><br><span class="line">    ElemType value; // 非零值</span><br><span class="line">&#125;Term;</span><br><span class="line">typedef struct sparsematrix</span><br><span class="line">&#123;</span><br><span class="line">    int m,n,t; //m是矩阵行数，n是矩阵列数，c是非零元速个数</span><br><span class="line">    Term table[maxSize]; // 存储非零元的三元组表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稀疏矩阵转置算法">稀疏矩阵转置算法</h3><p>第一种</p><ol><li>交换$i,j$</li><li>以$i,j$从小到大排序</li></ol><p><img src="https://img-blog.csdnimg.cn/20200822235016136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="转置算法一"></p><p>时间复杂度</p><ul><li>步骤一：$O(t)$ $t$——非零元素个数</li><li>排序复杂度$O(t^2)$或者$O(t\times\log_2\left(t\right))$</li></ul><p>第二种</p><ol><li>找到所有$&lt;i,0,a_{i0}&gt;$，交换$i,j$后依次保存到稀疏矩阵$B$</li><li>找到所有$&lt;i,1,a_{i1}&gt;$，交换$i,j$后依次保存到稀疏矩阵$B$</li><li>$…$</li></ol><p><img src="https://img-blog.csdnimg.cn/20200823000332888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="转置算法二"></p><p>时间复杂度</p><p>$O(n \times t)$</p><ul><li>$t$——非零元素个数</li><li>$n$——列数</li></ul><p>快速转置算法</p><ol><li>计算每列非零元素个数$num[j]$</li><li>计算前$j$列非零元素个数$k[j]$</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(j=0;j&lt;n;j++)</span><br><span class="line">    num[j] = 0;</span><br><span class="line">for(i=0;i&lt;t;i++)</span><br><span class="line">    num[A.table[i].col]++;</span><br><span class="line"></span><br><span class="line">for(j=0;j&lt;n;j++)</span><br><span class="line">    k[j] = 0;</span><br><span class="line">for(i=1;i&lt;t;i++)</span><br><span class="line">    k[i] = k[i-1] + num[i-1];</span><br></pre></td></tr></table></figure><p>都是$O(t+n)$，n为矩阵的列数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(i = 0;i &lt; t;i++)&#123;</span><br><span class="line">   int index = k[A.table[i].col]++;//先赋值再自增，是下一次的起始位置</span><br><span class="line">   B.table[index].col = A.table[i].row;</span><br><span class="line">   B.table[index].row = A.table[i].col;</span><br><span class="line">   B.table[index].value = A.table[i].value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串">字符串</h3><p>疑似不考</p><h2 id="树和二叉树">树和二叉树</h2><h3 id="术语">术语</h3><p>结点关系</p><p><img src="https://img-blog.csdnimg.cn/20200823012938696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="树"></p><ul><li>结点 树中的元素<code>E、A、F、B、G、C均为结点</code></li><li>边 根节点和子树跟之间</li><li>路径 从某个结点可达另一个结点<code>E、N间存在路径</code></li><li>双亲 该结点上连的点<code>A、F、B双亲是E；D双亲是F</code></li><li>孩子 该结点下连的点<code>E有3个孩子：A、F、B；D有一个孩子J</code></li><li>兄弟 有共同双亲的结点<code>A、F、B互为兄弟；C、D互为兄弟</code></li><li>后裔 子树的所有结点<code>C后裔为L、M、N</code></li><li>祖先 向上到根结点所有的点<code>L祖先为E、F、C</code></li></ul><p>度</p><ul><li>结点的度 结点的子树数<code>E：3；F：2；A：1；G：0</code></li><li>叶子 度为0的结点<code>B、G、J、M、N均为叶子</code></li><li>分支节点 度不为0的结点<code>E、A、F、C均为分支结点</code></li><li>树的度 结点度最大值<code>3</code></li></ul><p>高度</p><p><img src="https://img-blog.csdnimg.cn/20200823013802631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="树的层次"></p><ul><li>结点的层次 第几层<code>E:1；M:5</code></li><li>树的高度 最大层次<code>5</code></li></ul><p>有序/无序</p><ul><li>无序树 <img src="https://img-blog.csdnimg.cn/2020082301424070.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="无序树"> 各子树顺序可交换</li><li>有序树<img src="https://img-blog.csdnimg.cn/2020082301441723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"> 各子树顺序不可交换</li></ul><h3 id="二叉树">二叉树</h3><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242308308.png" alt=""></p><p>性质</p><ol><li>第$i$层至多$2^{i-1}$个结点</li><li>高度为$h$的二叉树最多$2^{h}-1$个结点</li><li>包含$n$个结点的二叉树，$[log_2(n+1)]{\leq}h{\leq}n$</li><li>叶结点：$n_0$；度为$2$的结点：$n_2$可以得出： $n_0=n_2+1$</li></ol><h3 id="特殊二叉树（3种）">特殊二叉树（3种）</h3><p>满二叉树</p><p>高度为$h$，且$2^h-1$结点</p><p><img src="https://img-blog.csdnimg.cn/20200823020014181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="满二叉树"></p><ul><li>满二叉树一定是完全二叉树，也是扩充二叉树</li></ul><p>完全二叉树</p><ul><li>除最下面两层度小于$2$，其他层结点度均为$2$</li><li>最下一层叶结点均依次集中在靠左若干位置</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823020453954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="完全二叉树"></p><ul><li>完全二叉树高度$h=[log_2(n+1)]$</li><li>由上到下、由左到右、从$0$编号根——$i=0$双亲——$[\dfrac{i-1}{2}]$左孩子——$2i+1$右孩子——$2i+2$</li></ul><p>扩充二叉树（2-树）</p><ul><li>除叶子结点，必须有两个孩子</li><li>仅有度$2$和$0$的结点，不存在度为$1$的结点</li></ul><p><img src="https://img-blog.csdnimg.cn/20200823021232158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="扩充二叉树"></p><h3 id="二叉树存储表示和部分运算">二叉树存储表示和部分运算</h3><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242308882.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">typedef struct btnode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType element; // 元素内容</span><br><span class="line">    struct btnode *lChild; // 左孩子指针</span><br><span class="line">    struct btnode *rChild; // 右孩子指针</span><br><span class="line">&#125;BTNode;</span><br><span class="line">typedef struct binarytree</span><br><span class="line">&#123;</span><br><span class="line">    BTNode *root;</span><br><span class="line">&#125;BinaryTree;</span><br><span class="line">//创建空二叉树</span><br><span class="line">void Create(BinaryTree *bt)</span><br><span class="line">&#123;</span><br><span class="line">    bt-&gt;root = NULL;</span><br><span class="line">&#125;</span><br><span class="line">//创建新结点</span><br><span class="line">BTNode* NewNode(ElemType x, BTNode *ln, BTNode *rn)</span><br><span class="line">&#123;</span><br><span class="line">    BTNode *p = (BTNode*)malloc(sizeof(BTNode)); // 申请空间</span><br><span class="line">    p-&gt;element = x; // 结点内容赋值</span><br><span class="line">    p-&gt;lChild = ln; // 左子树赋值</span><br><span class="line">    p-&gt;rChild = rn; // 右子树赋值</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">//返回根结点</span><br><span class="line">BOOL Root(BinaryTree *bt, ElemType *x)</span><br><span class="line">&#123;</span><br><span class="line">    if(!bt-&gt;boot) // 空树</span><br><span class="line">        return FALSE;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        *x = bt-&gt;root-&gt;element; // 赋值</span><br><span class="line">        return TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//构造二叉树</span><br><span class="line">void MakeTree(BinaryTree *bt, ElemType e, BinaryTree *left, BinaryTree *right) // bt:根地址 e:根值 left:左子树 right:右子树</span><br><span class="line">&#123;</span><br><span class="line">    if(bt-&gt;root  left==right)</span><br><span class="line">        return;</span><br><span class="line">    bt-&gt;root = NewNode(e,left-&gt;root,right-&gt;root);</span><br><span class="line">    left-&gt;root = right-&gt;root = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="先序遍历和层次遍历">先序遍历和层次遍历</h3><p>先根遍历：$O(n)$</p><ol><li>先访问根结点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void PreOrderTree(BinaryTree *bt)</span><br><span class="line">&#123;</span><br><span class="line">    PreOrder(bt-&gt;root); // 调用先序遍历函数</span><br><span class="line">&#125;</span><br><span class="line">void PreOrder(BTNode *t) // 先序遍历递归函数</span><br><span class="line">&#123;</span><br><span class="line">    if(!t) // 树空了直接返回</span><br><span class="line">        return;</span><br><span class="line">    printf(&quot;%c&quot;,t-&gt;element); //访问根结点</span><br><span class="line">    PreOrder(t-&gt;lChild); // 先序遍历左子树</span><br><span class="line">    PreOrder(t-&gt;rChild); // 先序遍历右子树</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ul><li>若二叉树为空，直接退出否则，初始化队列再将根结点进队</li><li>若队列不为空<ol><li>获取队头结点$p$，并将队头结点出队</li><li>访问结点$p$中的数据</li><li>$p$的左孩子进队</li><li>$p$的右孩子进队</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void LevelOrderTree(BinaryTree *tree)</span><br><span class="line">&#123;</span><br><span class="line">    Queue Q; // 存储BTNode结点类型指针的队列</span><br><span class="line">    BTNode *p;</span><br><span class="line">    if(!tree-&gt;root) // 二叉树为空</span><br><span class="line">        return;</span><br><span class="line">    Create(&amp;Q, tree-&gt;root); // 初始化队列</span><br><span class="line">    EnQueue(&amp;Q, tree-&gt;root); // 根结点进队</span><br><span class="line">    while(!IsEmpty(&amp;Q))</span><br><span class="line">    &#123;</span><br><span class="line">        Front(&amp;Q,&amp;p); DeQueue(&amp;Q); // 获取队头结点</span><br><span class="line">        printf(&quot;%c&quot;,p-&gt;element); // 访问结点p</span><br><span class="line">        if(p-&gt;lChild) EnQueue(&amp;Q,p-&gt;lChild); //若左孩子存在，则进队</span><br><span class="line">        if(p-&gt;rChild) EnQueue(&amp;Q,p-&gt;rChild); //若右孩子存在，则进队</span><br><span class="line">    &#125;</span><br><span class="line">    Destroy(&amp;Q); // 销毁队列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树和森林">树和森林</h3><p><img src="https://img-blog.csdnimg.cn/20200824094232641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="森林与二叉树"></p><p>先序遍历</p><p>若森林为空，则结束</p><ol><li>访问第一棵树根</li><li>第一棵树的根结点子树构成的森林</li><li>先序遍历其他树</li></ol><ul><li>先序遍历等于每棵树先序遍历简单拼接</li></ul><p>中序遍历</p><p>若森林为空，则遍历结束;否则</p><ol><li>中序遍历第一棵树的根结点的子树构成的森林</li><li>访问第一棵树的根</li><li>中序遍历其他树</li></ol><ul><li>中序遍历等于每棵树中序遍历简单拼接</li></ul><p>后序遍历</p><p>若森林为空，则遍历结束;否则</p><ol><li>后序遍历第一棵树的根结点的子树构成的森林</li><li>后序遍历其他树</li><li>访问第一棵树的根</li></ol><ul><li>后序遍历不等于每棵树中序遍历简单拼接</li><li>不常用</li></ul><p>层次遍历</p><ol><li>访问第一层所有结点</li><li>访问第二层所有结点</li><li>$…$</li></ol><p><img src="https://img-blog.csdnimg.cn/20200824095037296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="森林层次遍历"></p><h3 id="堆">堆</h3><p>最小堆</p><p>每个结点数据<strong>小于等于</strong>孩子结点</p><p>最大堆</p><p>每个结点数据<strong>大于等于</strong>孩子结点</p><p><img src="https://img-blog.csdnimg.cn/20200824095651550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="最小堆最大堆"></p><p>堆的判断</p><p><img src="https://img-blog.csdnimg.cn/20200824095936710.png#pic_center" alt="堆顺序表示"></p><p>最小堆</p><p>$k_i{\leq}k{2i+1}$和$k_i{\leq}k{2i+2}$</p><p>最大堆</p><p>$k_i{\geq}k{2i+1}$和$k_i{\geq}k{2i+2}$</p><p>建堆运算</p><p>从最后叶子的双亲$k_{[\frac{n-2}{2}]}$<strong>反方向</strong>直到根结点$k_0$，依次对每个结点$k_i$</p><ol><li>若该结点小于（大于）或等于其孩子，则结束</li><li>将该结点与与最小（大）孩子交换</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//向下调整算法</span><br><span class="line">void AdjustDown(ElemType heap[], int current, int border) // heap:存放序列数组 current:当前待调整序列中的位置 border:待调整序列的边界</span><br><span class="line">&#123;</span><br><span class="line">    int p = current;</span><br><span class="line">    int minChild;</span><br><span class="line">    ElemType temp;</span><br><span class="line">    while(2*p+1 &lt;= border) // 若p不是叶结点</span><br><span class="line">    &#123;</span><br><span class="line">        if((2*p+2 &lt;= border) &amp;&amp; (heap[2*p+1] &gt; heap[2*p+2])) // 右孩子存在 右孩子较小</span><br><span class="line">            minChild = 2*p+2;</span><br><span class="line">        else // 右孩子不存在 或 右孩子较大</span><br><span class="line">            minChild = 2*p+1; </span><br><span class="line">        </span><br><span class="line">        if(heap[p] &lt;= heap[minChild]) // 若当前结点不大于其最小的孩子，结束</span><br><span class="line">            break;</span><br><span class="line">        else // 否则将p和其最小孩子交换</span><br><span class="line">        &#123;</span><br><span class="line">            temp = heap[p] ; heap[p] = heap[minChild] ; heap[minChild] = temp;</span><br><span class="line">            p = minChild; // 当前下移元素的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//建堆算法</span><br><span class="line">void CreateHeap(ElemType heap[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=(n-2)/2 ; i&gt;-1 ;i--) // 从最后一个叶结点的双亲反向到根结点</span><br><span class="line">        AdjustDown(heap,i,n-1); // 依次执行向下调整</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先权队列">优先权队列</h3><ul><li>元素加入次序无关紧要</li><li>出队只取最高优先级的元素</li></ul><p>进队</p><ul><li>将新元素放堆尾，并按照最小堆（或最大堆）进行调整$O(log_2n)$</li></ul><p>出队</p><ul><li>直接取出堆顶元素$O(1)$</li><li>按照最小堆（或最大堆）进行适当调整$O(log_2n)$</li></ul><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242308854.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">typedef struct priorityQueue</span><br><span class="line">&#123;</span><br><span class="line">    ElemType *element; // 存储元素数据</span><br><span class="line">    int n; // 元素个数</span><br><span class="line">    int maxSize; // 优先队列容量</span><br><span class="line">&#125;PriorityQueue;</span><br><span class="line">//创建</span><br><span class="line">void CreatePQ(PriorityQueue *PQ, int mSize)</span><br><span class="line">&#123;</span><br><span class="line">    PQ-&gt;maxSize = mSize; // PQ最大容量赋值</span><br><span class="line">    PQ-&gt;n = 0; // PQ元素个数为0</span><br><span class="line">    PQ-&gt;element = (ElemType*)malloc(mSize*sizeof(ElemType)); // 申请空间</span><br><span class="line">&#125;</span><br><span class="line">//销毁</span><br><span class="line">void Destroy(PriorityQueue *PQ)</span><br><span class="line">&#123;</span><br><span class="line">    free(PQ-&gt;element); // 释放数组空间</span><br><span class="line">    PQ-&gt;n = 0; // PQ元素个数为0</span><br><span class="line">    PQ-&gt;maxSize = 0; // PQ容量清零</span><br><span class="line">&#125;</span><br><span class="line">//释放</span><br><span class="line">void Append(PriorityQueue *PQ, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    if(IsFull(PQ)) //满队</span><br><span class="line">        return;</span><br><span class="line">    PQ-&gt;element[PQ-&gt;n] = x; // 优先权队列最后一个元素后面插入一个元素</span><br><span class="line">    PQ-&gt;n++; // 元素数量+1</span><br><span class="line">    AdjustUp(PQ-&gt;element, PQ-&gt;n-1); // 新增元素向上调整</span><br><span class="line">&#125;</span><br><span class="line">//取出</span><br><span class="line">void Serve(PriorityQueue *PQ, ElemType *x)</span><br><span class="line">&#123;</span><br><span class="line">    if(IsEmpty(PQ)) // 空队</span><br><span class="line">        return;</span><br><span class="line">    *x = PQ-&gt;element[0]; // 栈顶元素赋值</span><br><span class="line">    PQ-&gt;n--; // 元素个数-1</span><br><span class="line">    PQ-&gt;element[0] = PQ-&gt;element[PQ-&gt;n]; // 用堆尾替代堆顶元素</span><br><span class="line">    AdjustDown(PQ-&gt;element, 0, PQ-&gt;n-1); // 向上调整</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈夫曼树">哈夫曼树</h3><p>扩充二叉树路径长度（不存在度为1的结点）</p><p>$$E=I+2n$$</p><ul><li>$I$——内路径长度根到分支结点路径和</li><li>$E$——外路径长度根到叶子的路径长度</li></ul><p>加权路径长度</p><p>$$WPL={\sum}_{k=1}^mw_kl_k$$</p><ul><li>$m$——叶结点数量</li><li>$w_k$第$k$个叶结点权值</li><li>$l_k$该叶结点路径长度</li><li>$WPL$——文本最终转换成编码的总编码长度</li></ul><h3 id="哈夫曼树和哈夫曼编码">哈夫曼树和哈夫曼编码</h3><ul><li>哈夫曼树是最小加权路径长度的扩充二叉树</li><li>分支节点权值$=$左孩子权值$+$右孩子权值</li></ul><p>实现方法</p><ol><li>选取最小的两个值</li><li>求和形成新的值，并与剩下的最小的求和</li></ol><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BinaryTree CreateHFMTree(int w[], int m)</span><br><span class="line">&#123;</span><br><span class="line">    BinaryTree x,y,z; // 二叉树变量</span><br><span class="line">    Create(PQ,m); // 初始化优先权队列PQ, 优先权存在根结点数据域</span><br><span class="line">    for(int i=0 ; i&lt;m ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        MakeTree(x,w[i],NULL,NULL); // 创建仅包含根结点二叉树，权值w[i]存入根结点</span><br><span class="line">        Append(PQ,x); // 将二叉树x插入优先权队列</span><br><span class="line">    &#125;</span><br><span class="line">    while(PQ.n &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        Serve(PQ,x); // 从PQ中取出根结点权值最小的二叉树，存入x</span><br><span class="line">        Serve(PQ,y); // 从PQ中取出根结点权值最小的二叉树，存入y</span><br><span class="line">    &#125;</span><br><span class="line">    //合并二叉树x,y</span><br><span class="line">    if(x.root.element &lt; y.root.element) // 左子树结点权值小于右子树</span><br><span class="line">        MakeTree(z, x.root.element+x.root.element, x, y);</span><br><span class="line">    else</span><br><span class="line">        MakeTree(z, x.root.element+x.root.element, y, x);</span><br><span class="line">    Append(PQ, z); // 新合成新二叉树z插入优先权队列</span><br><span class="line">Serve(PQ, x); // 获取优先权队列唯一二叉树，存入x，该二叉树即哈夫曼树</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈夫曼编码</p><ul><li>左0右1</li></ul><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242308595.png" alt=""></p><h2 id="集合和搜索">集合和搜索</h2><h3 id="集合">集合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int maxLength;</span><br><span class="line">    ElemType *element;</span><br><span class="line">&#125;ListSet;</span><br></pre></td></tr></table></figure><h3 id="顺序搜索">顺序搜索</h3><p>无序表</p><ol><li>从头开始检查，将指定元素$x$与关键字比较</li><li>若相等搜索成功</li><li>若搜索完整个表，不存在，则搜索失败</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int SeqSearch(ListSet L, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0 ; i &lt; L.n ; i++)</span><br><span class="line">        if(L.element[i] == x)</span><br><span class="line">            return i; // 搜索成功</span><br><span class="line">    return -1; // 搜索失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有序表</p><ul><li>关键字值满足$key_i{\leq}key_{i+1}$</li><li>$key_i$表示$a_i$的关键字</li></ul><p>步骤</p><ol><li>从头开始检查，将指定元素$x$与关键字比较</li><li>若相等搜索成功</li><li>若某个元素关键字大于指定元素$x$，则搜索失败</li></ol><p>无哨兵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int SeqSearch(ListSet L, ElemType x)&#123;    int i;    for(i=0 ; i &lt; L.n ; i++)    &#123;        if(L.element[i] == x)            return i; // 搜索成功        else if(L.element[i] &gt; x)            return -1; // 搜索失败    &#125;    return -1; // 搜索失败&#125;</span><br></pre></td></tr></table></figure><p>有哨兵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int SeqSearch(ListSet L, ElemType x)&#123;    int i;    L.element[L.n] = MaxNum; // MaxNum正无穷    for(i=0 ; L.element[i] &lt; x ; i++)        if(L.element[i] == x)            return i; // 搜索成功    return -1; // 搜索失败&#125;</span><br></pre></td></tr></table></figure><h3 id="对半搜索">对半搜索</h3><p>有序表$$(a_0,a_1,a_2,…,a_{n-1})$$</p><ul><li>有序表长$L\leq{0}$，搜索失败</li><li>有序表长$L{\geq}0$，取某个元素$a_{m}$与$x$比较$m=\dfrac{low+high}{2}$,$low=0,high=n-1$<ul><li>$a_m.key = x.key$，搜索成功</li><li>$a_m.key&gt;x.key$，二分搜索$(a_0,a_1,a_2,…,a_{m-1})$</li><li>$a_m.key&lt;x.key$，二分搜索$(a_{m+1},a_{m+2},…,a_{n-1})$</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">int BinSearch(ListSet L, ElemType x, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    if(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        int m = (low+high) / 2; // 对半分割</span><br><span class="line">        if(x &lt; L.element[m])</span><br><span class="line">            return BinSearch(L,x,low,m-1);</span><br><span class="line">        else if(x &gt; L.element[m])</span><br><span class="line">            return BinSearch(L,x,m+1,high);</span><br><span class="line">        else</span><br><span class="line">            return m; // 搜索成功</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; // 搜索成功</span><br><span class="line">&#125;</span><br><span class="line">//迭代</span><br><span class="line">int BinSearch(ListSet L, ElemType x)</span><br><span class="line">&#123;</span><br><span class="line">    int m,kow = 0;high = L.n-1;</span><br><span class="line">    while(low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        m = (low+high)/2; // 对半分割</span><br><span class="line">        if(x &lt; L.element[m])</span><br><span class="line">            high = m-1;</span><br><span class="line">        else if(x &gt; L.element[m])</span><br><span class="line">            low = m+1;</span><br><span class="line">        else</span><br><span class="line">            return m;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索长度">搜索长度</h3><p>搜索成功</p><p>搜索失败</p><p><strong>无序表顺序搜索</strong></p><p>$$\dfrac{n+1}{2}$$</p><p>$$n$$</p><p><strong>有序表顺序搜索</strong></p><p>$$\dfrac{n+1}{2}$$</p><p>$$2+{\dfrac{n}{2}}$$</p><p><strong>对半搜索</strong></p><p>$$S_{success}=\dfrac{2^n(n-1)+k(n+1)+1}{N}$$ $$N=2^n-1+k$$</p><p>$$S_{fail}=\dfrac{n2^n+(n+2)k}{2^n+k}$$</p><h2 id="搜索树">搜索树</h2><h3 id="二叉搜索树">二叉搜索树</h3><ul><li>左子树小于根结点</li><li>右子树大于根结点</li><li>若以<strong>中序遍历</strong>二叉搜索树，将得到递增有序序列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//定义集合项</span><br><span class="line">typedef struct entry</span><br><span class="line">&#123;</span><br><span class="line">    KeyType Key;</span><br><span class="line">    DataType Data;</span><br><span class="line">&#125;T</span><br><span class="line">//定义结点</span><br><span class="line">typedef struct btnode</span><br><span class="line">&#123;</span><br><span class="line">    T Element;</span><br><span class="line">    struct btnode *lChild, *rChild;</span><br><span class="line">&#125;BTNode;</span><br><span class="line">//定义搜索树</span><br><span class="line">typedef struct btree</span><br><span class="line">&#123;</span><br><span class="line">    BTNode *root;</span><br><span class="line">&#125;BTree;</span><br></pre></td></tr></table></figure><p>查找关键字$x$</p><ol><li>二叉树为空，搜索失败</li><li>将$x$与根结点比较<ul><li>$k$小于该结点，搜索左子树</li><li>$k$大于该结点，搜索右子树</li><li>$k$等于该结点，搜索成功</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//递归</span><br><span class="line">BTNode *Find(BTNode *p,KeyType k)</span><br><span class="line">&#123;</span><br><span class="line">    if(!p)</span><br><span class="line">        return NULL; // 搜索失败</span><br><span class="line">    if(k == p-&gt;element.key)</span><br><span class="line">        return p; // 搜索成功</span><br><span class="line">    if(k &lt; p-&gt;element.key)</span><br><span class="line">        return Find(p-&gt;lChild,k);</span><br><span class="line">    return Find(p-&gt;rChild,k);</span><br><span class="line">&#125;</span><br><span class="line">BOOL BtSearch(BTree Bt,KeyType k,T *x)</span><br><span class="line">&#123;</span><br><span class="line">    BTNode *p = Find(Bt.root,k);</span><br><span class="line">    if(p)</span><br><span class="line">    &#123;</span><br><span class="line">        *x = p-&gt;element;</span><br><span class="line">        return TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//迭代</span><br><span class="line">BOOL BtSearch(Btree Bt,KeyType k,T *x)</span><br><span class="line">&#123;</span><br><span class="line">    BTNode *p = Bt.Root; // 从根结点出发</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        if(k &lt; p-&gt;element.key) // 从左分支继续向下搜索</span><br><span class="line">            p = p-&gt;lChild;</span><br><span class="line">        else if(k &gt; p-&gt;element.key) // 从右分支继续向下搜索</span><br><span class="line">            p = p-&gt;rChild;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            *x = p-&gt;element; // 搜索成功</span><br><span class="line">            return TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入</p><ul><li>向下搜索$x$</li><li>搜索失败处插入$x$</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL Insert(Btree *bt, T x)&#123;    BTNode *p = bt-&gt;root, *q, *r; // p:从根节点向下搜索 q:记录搜索失败上一层结点    KeyType k = x.key;    while(p)    &#123;        q = p;        if(k &lt; p-&gt;element.key)            p = p-&gt;lChild;        else if(k &gt; p-&gt;element.key)            p = p-&gt;rChild;        else            return FALSE;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>删除叶子结点</p><p><code>直接删</code></p><ol><li>将待删除结点双亲结点指向NULL</li><li>释放待删除结点</li></ol><p>删除有一个孩子结点</p><p><code>爷带孙</code></p><ol><li>待删除结点的双亲结点指向待删除结点的孩子</li><li>释放待删除结点</li></ol><p>删除有两个孩子结点</p><ol><li>从后代选择一个覆盖待删除结点<ul><li>保持二叉搜索树有序性==左孩子$\leq$代替这$\leq$右孩子==</li><li>容易删除==只有一个孩子或没有孩子==</li></ul></li><li>删除重复的代替者</li></ol><h3 id="二叉平衡树">二叉平衡树</h3><ul><li>二叉搜索树</li><li>左右子树高度$h’\leq{1}$</li><li>左右子树都是二叉平衡树</li></ul><p><img src="https://img-blog.csdnimg.cn/20200824193318941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="二叉平衡树"></p><ul><li>平衡因子——左子树与右子树高度差$h_{left}-h_{right}$</li></ul><p>二叉平衡树插入</p><ul><li>先按照普通二叉搜索树插入</li><li>若不平衡，则进行调整<ul><li>先找到平衡因子超过$1$的根结点$s$<ol><li>$LL/RR$类型——单旋转新结点插入$s$的左/右结点<img src="https://img-blog.csdnimg.cn/20200824194953180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="单旋转"></li><li>$LR/RL$类型——双旋转<img src="https://img-blog.csdnimg.cn/20200824195459362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="双旋转"></li></ol></li></ul></li></ul><h3 id="m叉搜索树">m叉搜索树</h3><p><img src="https://img-blog.csdnimg.cn/20200824222242470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="四叉搜索树"></p><ul><li>空树——失败结点</li><li>==失败结点不是叶子节点==</li><li>根结点最多$m$棵子树<img src="https://img-blog.csdnimg.cn/20200824222526959.png#pic_center" alt="m阶搜索树结构"><ul><li>$k_i$是元素关键字</li><li>$P_i$是指向子树的指针</li><li>$n$为该结点元素个数，$1{\leq}n{\leq}m$</li></ul></li><li>子树$P_i$所有关键字大于$K_i$，小于$K_{i+1}$</li><li>子树$P_0$所有关键字值小于$K_1$子树$P_n$上所有关键字大于$K_n$</li><li>子树$P_i(0{\leq}i{\leq}n)$也是$m$叉二叉树</li><li><strong>结点最多存放_m-1_个元素和_m_个指针</strong></li><li><strong>结点里元素个数比包含指针少$1$</strong></li></ul><p>性质</p><ol><li>高度为$h$的$m$二叉树最多$m^h-1$个元素高度为$h$的$m$二叉树最多$\dfrac{m^h-1}{m-1}$个结点</li><li>含有$N$个元素的$m$叉搜索树高度$h$满足$h{\leq}log_m(N+1)$</li></ol><h3 id="B-树">B-树</h3><ul><li>或者为<strong>空树</strong></li><li>或满足$m$叉搜索树<ul><li>根结点<strong>至少两个</strong>孩子==可以只有一个元素==</li><li>除根结点和失败结点所有结点**至少$\dfrac{m}{2}$**个孩子==确保B-树不会退化为单支树==</li><li>所有失败结点在同一层==考虑平衡性==</li></ul></li></ul><p>判定性质</p><ul><li>一个结点<strong>最多</strong>$m$个孩子，$m-1$个关键字</li><li>除根结点与失败结点每个结点<strong>至少</strong>$\dfrac{m}{2}$个孩子，$\dfrac{m}{2}-1$个关键字</li><li>根结点最少2个孩子</li><li>失败结点均在同一层，失败结点的双亲是叶子结点</li></ul><p>判定方法</p><ol><li>失败结点是否在同一层</li><li>根结点是否至少$2$个孩子</li><li>确定$m$并计算$\dfrac{m}{2}$</li><li>查看除根结点与失败者外所有结点的孩子数量是否少于$\dfrac{m}{2}$</li></ol><p>性质</p><ul><li>$N=s-1$$s$——失败点总数$N$——$B-$树失败点总数</li><li>含有$N$个元素的$m$阶$B-$树高度$h$：$h{\leq}1+log_{\frac{m}{2}}{\dfrac{N+1}{2}}$</li></ul><p>搜索</p><p><img src="https://img-blog.csdnimg.cn/20200827211009950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="B-树搜索"></p><ol><li>$B-$树中找结点，执行访问磁盘次数最多$log_{\frac{m}{2}}{\dfrac{N+1}{2}}$</li><li>结点中找关键字</li></ol><p>插入</p><p><img src="https://img-blog.csdnimg.cn/20200827211149146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="B-树插入"></p><p>步骤</p><ol><li>搜索待插入元素若已存在，则插入失败</li><li>插入停留的失败结点的叶子结点中</li><li>将结点分为{$1$~${\dfrac{m}{2}-1}$}、{$\dfrac{m}{2}$}、{${\dfrac{m}{2}}$~$m$}</li><li>将{$\dfrac{m}{2}$}和其指针插入其双亲结点<ul><li>根结点会向上形成一个新的根结点</li></ul></li></ol><p>删除</p><ol><li>叶子结点直接删除</li><li>否则以其右子树最小元素替换<img src="https://img-blog.csdnimg.cn/20200827212853844.gif#pic_center" alt="B-树删除"></li><li>如发生下溢出，则若其左右兄弟有多于$\dfrac{m}{2}$个元素，则向其接一个元素<img src="https://img-blog.csdnimg.cn/20200827213312946.gif#pic_center" alt="B-树删除（下溢出）"></li><li>没有富余兄弟，与兄弟合并且将两结点之间元素下移<img src="https://img-blog.csdnimg.cn/20200827214242240.gif#pic_center" alt="B-树删除合并"><img src="https://img-blog.csdnimg.cn/20200827214413870.gif#pic_center" alt="B-树删除合并"></li></ol><h2 id="散列表">散列表</h2><h3 id="散列技术">散列技术</h3><p>散列函数（$h,hash$）:存储关键字($key$)和存储位置($Loc$)之间关系</p><ul><li>冲突：$key_1{\neq}key_2$,$h(key_1)=h(key_2)$</li><li>同义词：对给定$h$，具有相同散列值不同数字</li></ul><h3 id="常见散列函数">常见散列函数</h3><p>除留余数法</p><p>$h(key)=key\%M$</p><p>==模值取不超过$M$的素数$P$更好==</p><p>不足</p><ol><li>存在不动点$h(0)=0$,与均分布相悖</li><li>相邻的关键字散列到相邻地址</li></ol><p>除留余数法改进MAD</p><p>$h(key)=(key*a+b)%P$</p><ul><li>$b$作为偏移量，消除了不动点</li><li>$a$作为间隔量，原本相邻地址变成间隔$a$</li></ul><p>平方取中法</p><p>$h(key)=(key)^2$的中间若干位</p><ul><li>位数$k$满足：$10^{k-1}{\leq}n{\leq}10^k$$n$为集合中元素个数</li></ul><p>折叠法</p><ol><li>折叠法自左到右，分为位数相等几部分，每部分位数与散列表地址相同</li><li>将数据叠加</li></ol><h3 id="冲突处理技术">冲突处理技术</h3><ul><li>开散列法存储主表之外</li><li>闭散列法存储主表之内</li></ul><p>拉链法</p><p><img src="https://img-blog.csdnimg.cn/20200828075629109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="拉链法"></p><p>时间复杂度</p><ul><li>查找：$O(\dfrac{n}{M})$</li><li>插入：$O(\dfrac{n}{M})$</li><li>删除：$O(\dfrac{n}{M})$</li></ul><p>线性探查法</p><ul><li>开放地址法</li></ul><p>解决方式</p><p>$h_i=(h(key)+i)modM$</p><p>聚集问题：线性聚集</p><p>二次探查法</p><ul><li>开放地址法</li></ul><p>解决方式</p><p>$h_{2i-1}=(h(key)+i^2)modM$</p><p>$h_{2i}=(h(key)-i^2)modM$</p><p>聚集问题：二次聚集</p><p>双散列法</p><ul><li>开放地址法</li></ul><p>解决方式</p><p>$H_{i}=(h_1(key)+ih_2(key))modM$</p><h3 id="总结">总结</h3><p>冲突处理方法</p><p>解决方式</p><p>开/闭散列法</p><p>冲突问题</p><p>成功搜索长度</p><p>失败搜索长度</p><p>拉链法</p><p>$$/$$</p><p>开散列法</p><p>无</p><p>$$1+\dfrac{\alpha}{2}$$</p><p>$$\alpha+e^{-\alpha}$$</p><p>线性探查法</p><p>$$h_i=(h(key)+i)modM$$</p><p>开放地址法</p><p>线性聚集</p><p>$$\dfrac{1}{2}(1+\dfrac{1}{1-\alpha})$$</p><p>$$\dfrac{1}{2}(1+\dfrac{1}{(1-\alpha)^2})$$</p><p>二次探查法</p><p>$$h{2i-1}=(h(key)+i^2)modM$$ $$h{2i}=(h(key)-i^2)modM$$</p><p>开放地址法</p><p>二次聚集</p><p>$$-\dfrac{1}{\alpha}log_e(1-\alpha)$$</p><p>$$-\dfrac{1}{1-\alpha}$$</p><p>双散列法</p><p>$$H_{i}=(h_1(key)+ih_2(key))modM$$</p><p>开放地址法</p><p>$$/$$</p><p>$$-\dfrac{1}{\alpha}log_e(1-\alpha)$$</p><p>$$-\dfrac{1}{1-\alpha}$$</p><h2 id="图">图</h2><h3 id="基本概念">基本概念</h3><ul><li>$G=(V,E)$<ul><li>$V$——结点</li><li>$E$——边</li></ul></li><li>$&lt;u,v&gt;$——有向图</li><li>$(u,v)$——无向图</li></ul><h3 id="基本术语">基本术语</h3><ul><li>自回路：图中存在$&lt;u,u&gt;$或$(u,u)$</li><li>多重图：两个顶点间有多条相同的边</li></ul><p><img src="https://img-blog.csdnimg.cn/20200825013921685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="自回路和多重图"></p><ul><li>完全图：图有最多的边<ul><li>无向完全图：${\dfrac{n(n-1)}{2}}$条边</li><li>有向完全图：$n(n-1)$条边<img src="https://img-blog.csdnimg.cn/20200825014258667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="完全图"></li></ul></li><li>简单路径：除起始点，路径上其他各点都不相同</li><li>回路：起始点相同的简单路径</li><li>连通图：任两个点之间想通强连通图：最多$n(n-1)$边</li><li>连通分量：无向图极大连通子图<img src="https://img-blog.csdnimg.cn/2020082501510949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="连通分量"><ul><li>连通分量可能有多个</li><li>若加一个点，仍然连通，则非连通分量</li></ul></li><li>顶点的度：与该顶点相关联的边的数目<ul><li>入度：以$v$为头边的数目</li><li>出度：以$v$为尾边的数目</li></ul></li></ul><h3 id="领接矩阵">领接矩阵</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">typedef struct mgraph</span><br><span class="line">&#123;</span><br><span class="line">    ElemType **a;// 动态二维数组，用来存储邻接矩阵</span><br><span class="line">    int n; // 图中顶点数</span><br><span class="line">    int e; // 图中边数</span><br><span class="line">    ElemType noEdge; // 两顶点无边的值</span><br><span class="line">&#125;mGraph;</span><br><span class="line">//初始化</span><br><span class="line">void Init(mGraph *mg, int nSize, ElemType noEdgeValue)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j;</span><br><span class="line">    mg-&gt;n = nSize; // 初始化顶点数</span><br><span class="line">    mg-&gt;e = 0; // 初始化边数</span><br><span class="line">    mg-&gt;noEdge = noEdgeValue; // 初始化无边时的取值</span><br><span class="line">    mg-&gt;a = (ElemType**)malloc(nSize*sizeof(ElemType**)); // 数组申请空间</span><br><span class="line">    </span><br><span class="line">    for(i=0; i &lt; mg-&gt;n ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mg-&gt;a[i] = (ElemType*)malloc(nSize*sizeof(ElemType)); // 申请结点空间</span><br><span class="line">        for(j=0 ;j &lt; mg-&gt;n ; j++)</span><br><span class="line">            mg-&gt;a[i][j] = mg-&gt;noEdge;</span><br><span class="line">        mg-&gt;a[i][i] = 0; // 回路</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//销毁</span><br><span class="line">void Destroy(mGraph *mg)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0 ; i &lt; mg-&gt;n ; i++)</span><br><span class="line">        free(mg-&gt;a[i]); // 依次释放n个一维数组的存储空间</span><br><span class="line">    free(mg-&gt;a); // 释放以为指针数组存储空间</span><br><span class="line">&#125;</span><br><span class="line">//搜索</span><br><span class="line">Status Exist(mGraph *mg, int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">    if(u&lt;0  v&lt;0  u &gt; mg-&gt;n-1  v &gt; mg-&gt;n-1  u==v) // 越界 回路</span><br><span class="line">        return FALSE;</span><br><span class="line">    else if(mg-&gt;a[u][v] != mg-&gt;noEdge) // 不为不存在的边</span><br><span class="line">        return True;</span><br><span class="line">    return False;</span><br><span class="line">&#125;</span><br><span class="line">//插入</span><br><span class="line">Status Insert(mGraph *mg, int u, int v, ElemType w)</span><br><span class="line">&#123;</span><br><span class="line">    if(u&lt;0  v&lt;0  u &gt; mg-&gt;n-1  v &gt; mg-&gt;n-1  u==v) // 越界 回路</span><br><span class="line">        return ERROR;</span><br><span class="line">    else if(mg-&gt;a[u][v] != mg-&gt;noEdge) // 插入边已存在</span><br><span class="line">        return Duplicate;</span><br><span class="line">    else</span><br><span class="line">        mg-&gt;a[u][v] = w; // 插入新边</span><br><span class="line">    mg-&gt;e++; // 边数+1</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">//删除</span><br><span class="line">Status Remove(mGraph *mg, int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">    if(u&lt;0  v&lt;0  u &gt; mg-&gt;n-1  v &gt; mg-&gt;n-1  u==v) // 越界 回路</span><br><span class="line">        return ERROR;</span><br><span class="line">    else if(mg-&gt;a[u][v] != mg-&gt;noEdge) // 删除边不存在</span><br><span class="line">        return NotPresent;</span><br><span class="line">    else</span><br><span class="line">        mg-&gt;a[u][v] = mg-&gt;noEdge; // 删除边</span><br><span class="line">    mg-&gt;e--; // 边数+1</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点</p><ol><li>便于判断两个顶点是否有边</li><li>便于计算各个顶点度<ul><li>对于无向图，第$i$行顶点之和即为顶点$i$的度</li><li>对于有向图，第$i$行顶点之和为顶点$i$的出度 第$i$行顶点之和为顶点$i$的入度</li></ul></li></ol><p>缺点</p><ol><li>统计边的数目时间复杂度$O(n^2)$</li><li>空间复杂度$O(n^2)$</li></ol><h3 id="领接表">领接表</h3><ul><li>用$n$个单链表代替邻接矩阵中的$n$行</li><li>每个顶点对应一个单链表</li></ul><p><img src="https://img-blog.csdnimg.cn/20200825094259575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="邻接表"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">typedef struct eNode // 边结点定义</span><br><span class="line">&#123;</span><br><span class="line">    int AdjVex; // 邻接点域</span><br><span class="line">    ElemType w; // 权重域</span><br><span class="line">    struct ENode* NextArc; // 指针域</span><br><span class="line">&#125;ENode;</span><br><span class="line">typedef struct lGraph</span><br><span class="line">&#123;</span><br><span class="line">    ENode **a; // 指向一维指针数组</span><br><span class="line">    int n; // 顶点数</span><br><span class="line">    int e; // 边数</span><br><span class="line">&#125;LGraph;</span><br><span class="line">//初始化</span><br><span class="line">Status Init(LGraph *lg, int nSize)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    lg-&gt;n = nSize;</span><br><span class="line">    lg-&gt;e = 0;</span><br><span class="line">    lg-&gt;a = (ENode**)malloc(nSize*sizeof(ENode*));</span><br><span class="line">    if(!lg-&gt;a)</span><br><span class="line">        return ERROR;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(i=0 ; i &lt; lg-&gt;n ; i++)</span><br><span class="line">            lg-&gt;a[i] = NULL; // 将指针a置空</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//插入</span><br><span class="line">Status Insert (LGraph *lg, int u, int v, ElemType w)</span><br><span class="line">&#123;</span><br><span class="line">    ENode* P;</span><br><span class="line">    if(u&lt;0  v&lt;0  u &gt; lg-&gt;n-1  v &gt; lg-&gt;n-1  u==v) // 输入参数无效</span><br><span class="line">    return Error;</span><br><span class="line">    if(Exist(lg,u,v)) // 边是否存在</span><br><span class="line">    return Duplicate;</span><br><span class="line">    else</span><br><span class="line">    p=(ENode*)malloc(sizeof(ENode));</span><br><span class="line">    p-&gt;adjVex = v;</span><br><span class="line">    p-&gt;w = w;</span><br><span class="line">    p-&gt;nextArc = lg-&gt;a[u];</span><br><span class="line">    lg-&gt;a[u] = p;</span><br><span class="line">    lg-&gt;e++;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line">//删除</span><br><span class="line">Status Remove(LGraph *lg, int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">    ENode *p,*q;</span><br><span class="line">    if(u&lt;0  v&lt;0  u &gt; lg-&gt;n-1  v &gt; lg-&gt;n-1  u==v) // 输入参数无效</span><br><span class="line">    return Error;</span><br><span class="line">    p = lg-&gt;a[u];</span><br><span class="line">    q = NULL;</span><br><span class="line">    while(p &amp;&amp; p-&gt;adjVex != v) // 查找待删除边是否存在</span><br><span class="line">    &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;nextArc;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!p)</span><br><span class="line">        return NotPresent;</span><br><span class="line">    if(q)</span><br><span class="line">        q-&gt;nextArc = p-&gt;nextArc;</span><br><span class="line">    else</span><br><span class="line">        lg-&gt;a[u] = p-&gt;nextArc;</span><br><span class="line">    free(p);</span><br><span class="line">    lg-&gt;e--;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点</p><ol><li>便于统计边数$O(n+e)$</li><li>空间复杂度$O(n+e)$</li></ol><p>缺点</p><ol><li>不便判断顶点之间是否有边$O(n)$</li><li>不便于计算各个顶点度</li></ol><h3 id="深度优先搜索（DFS）">深度优先搜索（DFS）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void DFS(int v, int visited[], LGraph g)</span><br><span class="line">&#123;</span><br><span class="line">    ENode *w;</span><br><span class="line">    printf(&quot;%d&quot;,v); // 访问顶点v</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    for(w = g.a[v] ; w ; w = w&gt;nextArc)</span><br><span class="line">        if(!visited[w-&gt;adjVex])</span><br><span class="line">            DFS(w-&gt;adjVex, visited, g);</span><br><span class="line">&#125;</span><br><span class="line">void DFSTraverse(LGraph g)</span><br><span class="line">&#123;</span><br><span class="line">    int i; // 动态生成标记数组</span><br><span class="line">    int *visited = (int*)malloc(g.n*sizeof(int)); // 初始化标记数组</span><br><span class="line">    for(i=0 ; i &lt; g.n ; i++) // 逐一检查每个顶点，若未被访问，则调用DFS</span><br><span class="line">        visited[i] = 0;</span><br><span class="line">    for(i=0 ; i &lt; g.n ; i++)</span><br><span class="line">        if(!visited[i])</span><br><span class="line">            DFS(i, visited, g);</span><br><span class="line">    free(visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>邻接表$O(n+e)$</li><li>邻接矩阵$O(n^2)$</li></ul><h3 id="宽度优先搜索（BFS）">宽度优先搜索（BFS）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void BFS(int v, int visited[], LGraph g)</span><br><span class="line">&#123;</span><br><span class="line">    ENode *w;</span><br><span class="line">    Queue q;</span><br><span class="line">    create(&amp;q, g.n); // 初始化队列</span><br><span class="line">    visited[v]=1; // 为顶点v打上访问标记</span><br><span class="line">    printf(&quot;%d&quot;,v); // 访问顶点v</span><br><span class="line">    EnQueue(&amp;q,v); // 将顶点v放入队列</span><br><span class="line">    while(!IsEmpty(&amp;q))</span><br><span class="line">    &#123;</span><br><span class="line">        Front(&amp;q,&amp;u);</span><br><span class="line">        DeQueue(&amp;q); // 队首u出队</span><br><span class="line">        for(w = g.a[u] ; w ; w = w-&gt;nextArc) // 依序搜索u的未被访问过邻接点，访问并将其入队</span><br><span class="line">            if(!visited[w-&gt;adjVex])</span><br><span class="line">            &#123;</span><br><span class="line">                visited[w-&gt;adjVex] = 1;</span><br><span class="line">                printf(&quot;%d&quot;,w-&gt;adjVex);</span><br><span class="line">                EnQueue(&amp;q,w-&gt;adjVex);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void BFSTraverse(LGraph g)</span><br><span class="line">&#123;</span><br><span class="line">    int i; // 动态链接生成访问标记数组</span><br><span class="line">    int *visited = (int*)malloc(g.n*sizeof(int));</span><br><span class="line">    for(i=0 ; i &lt; g.n ; i++) // 初始化标记数组</span><br><span class="line">        visited[i] = 0;</span><br><span class="line">    for(i=0 ; i &lt; g.n ; i++) // 依次检查每个检查点</span><br><span class="line">        if(!visited[i]) // 若未被访问</span><br><span class="line">            BFS(i, visited, g);</span><br><span class="line">    free(visited);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>邻接表$O(n+e)$</li><li>邻接矩阵$O(n^2)$</li></ul><h3 id="拓扑排序">拓扑排序</h3><p>AOV网：有向边表示领先关系的<strong>有向无环</strong>图</p><p><img src="https://img-blog.csdnimg.cn/20200826231034134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="AOV"></p><p>拓扑排序过程</p><ol><li>找到入度$0$的点</li><li>删除其所有边</li><li>重复</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//计算各个点的出入度</span><br><span class="line">void Degree(int* inDegree, LGraph g)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ENode *p;</span><br><span class="line">    for(i=0 ; i &lt; g.n ; i++) // 数组初始化</span><br><span class="line">        inDegree[i] = 0;</span><br><span class="line">    for(i=0 ; i &lt; g.n ; i++)</span><br><span class="line">        for(p = g.a[i] ; p ; p = p-&gt;nextArc) // 检查顶点vi所有邻接点</span><br><span class="line">            inDegree[p-&gt;adjVex]++; // 邻接点入度+1</span><br><span class="line">&#125;</span><br><span class="line">//拓扑排序</span><br><span class="line">Status TopoSort(int* topo, LGraph g)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    ENode *p;</span><br><span class="line">    Stack S;</span><br><span class="line">    int* inDegree = (int*)malloc(sizeof(int) * g.n);</span><br><span class="line">    Degree(inDegree, g); // 计算顶点入度</span><br><span class="line">    Create(&amp;S, g.n); // 初始化栈堆</span><br><span class="line">    for(i=0 ; i &lt; g.n ; i++)</span><br><span class="line">        if(!inDegree[i])</span><br><span class="line">            Push(&amp;S, i); // 入度为0顶点入栈</span><br><span class="line">    while(!IsEmpty(&amp;S)) // 若栈S不空</span><br><span class="line">    &#123;</span><br><span class="line">        Top(&amp;S, &amp;i); Pop(&amp;S); //顶点v出栈</span><br><span class="line">        topo[m] = i; // 将v输出到拓扑回归序列中</span><br><span class="line">        m++; // 对输出顶点计数</span><br><span class="line">        for(p=g.a[i] ; p; p = p-&gt;nextArc) // 检查顶点vi所有邻接点</span><br><span class="line">        &#123;</span><br><span class="line">            k = p-&gt;adjVex;</span><br><span class="line">            inDegree[K]--; // 入度为0邻接点进栈</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(m &lt; g.n) // 若还有顶点为输出，则表明有环</span><br><span class="line">        return Error;</span><br><span class="line">    else</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键路径">关键路径</h3><p>AOE网：有向边表示持续时间的<strong>有向无环带权</strong>图</p><p><img src="http://192.168.1.35/wp-content/uploads/2022/02/%E5%9B%BE%E7%89%87-16.png" alt=""></p><p>路径长度：路径上各活动持续时间的总和（即路径上所有权之和）。</p><p>完成工程的最短时间：从工程开始点（源点）到完成点（汇点）的最长路径称为完成工程的最短时间。</p><p>关键路径：路径长度最长的路径称为关键路径。</p><p>需要的四个变量：</p><ol><li>$E_{early}(v_i)$事件最早发生时间，顶点最早发生时间。</li><li>$E_{late}(v_i)$事件最晚发生时间，顶点最晚发生时间。</li><li>$A_{early}(a_k)$活动最早开始时间，边最早开始时间。</li><li>$A_{late}(a_k)$活动最晚开始时间，边最晚开始时间。</li></ol><p>步骤：</p><ol><li>先求$E_{early}(v_i)$，从0到最后</li><li>再求$E_{late}(v_i)$，从最后到0</li><li>$A_{early}(a_k)$=$E_{early}(v_i)$</li><li>$A_{late}(a_k)$=$E_{late}(v_i)$-$w(v,j)$</li><li>$A_{early}(a_k)$=$A_{late}(a_k)$关键顶点</li><li>即可确定关键路径</li></ol><h3 id="最小代价生成树">最小代价生成树</h3><p>边权值和最小</p><p>普利姆算法（Prim）</p><ol><li>分为已选$U$与未选$V$</li><li>选择$U$和$V$之间最小值</li><li>重复直到选完所有点</li></ol><p><img src="https://img-blog.csdnimg.cn/20200827003824599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="普利姆算法"></p><ul><li><strong>nearst</strong>该点与未选择区域最近的点</li><li><strong>lowcost</strong>最短的距离</li><li><strong>mark</strong>是否已被选择</li></ul><p>克鲁斯卡尔算法（Kruskal）</p><ol><li>选择图中最短的边</li><li>若未形成回路，则继续选</li><li>形成了回路，再去选其他的</li></ol><h3 id="单源最短路径">单源最短路径</h3><p>迪杰斯特拉算法</p><p><img src="https://img-blog.csdnimg.cn/20200827005202317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="最短路径"></p><ol><li>选已选点最短路径</li><li>更新${d,path}$</li></ol><p><img src="https://img-blog.csdnimg.cn/20200827005122146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjY4MjQ4,size_16,color_FFFFFF,t_70#pic_center" alt="迪杰斯特拉算法"></p><h2 id="排序">排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct entry</span><br><span class="line">&#123;</span><br><span class="line">    KeyType key; // 排序关键字</span><br><span class="line">    DataType data; // 数据项</span><br><span class="line">&#125;Entry;</span><br><span class="line">typedef struct list // 顺序表</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    Entry D[MaxSize];</span><br><span class="line">&#125;List</span><br></pre></td></tr></table></figure><h3 id="选择法">选择法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void SelectSort(List* list)</span><br><span class="line">&#123;</span><br><span class="line">    int minIndex,startIndex = 0;</span><br><span class="line">    while(startIndex &lt; list-&gt;n-1)</span><br><span class="line">    &#123;</span><br><span class="line">        minIndex = FindMin(*list, startIndex);</span><br><span class="line">        Swap(list-&gt;D, startIndex, minIndex);</span><br><span class="line">        startIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序">插入排序</h3><ol><li>前$i$元素组成有序区后$n-i-1$个元素组成无序区</li><li>将第$i$个元素按序插入有序区</li><li>以此类推</li></ol><p><img src="http://192.168.1.35/wp-content/uploads/2022/02/%E5%9B%BE%E7%89%87-17-1024x492.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void InsertSort(List *list)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j; // i标识待插入元素下标</span><br><span class="line">    Entry insertItem; // 每一趟待插入元素</span><br><span class="line">    for(i=1 ; i &lt; list-&gt;n ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insertItem = list-&gt;D[i];</span><br><span class="line">        for(j=i-1 ; j &gt;= 0 ; j--) // 不断将有序序列后移，为待插入元素留一个位置</span><br><span class="line">        &#123;</span><br><span class="line">            if(insertItem.key &lt; list-&gt;D[j].key)</span><br><span class="line">                list-&gt;D[j+1] = list-&gt;D[j];</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        list-&gt;D[j+1] = insertItem; // 待插入元素有序存放至有序序列中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡">冒泡</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void BubbleSort(List *list)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j; // i标识每趟排序范围最后一个元素下标，每趟排序下标为0~i</span><br><span class="line">    BOOL isSwap = FALSE; // 标记一趟排序中是否发生了元素交换</span><br><span class="line">    for(i = list-&gt;n-1 ; i &gt; 0 ; i--)</span><br><span class="line">        for(j = 0 ; j &lt; i ; j++)</span><br><span class="line">            if(list-&gt;D[j].key &gt; list-&gt;D[j+1].key)</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(list-&gt;D, j, j+1);</span><br><span class="line">                isSwap = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">    if(!isSwap) // 若本趟排序无元素交换，排序完成</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快排">快排</h3><ol><li>待排序序列元素数量小于1，退出</li><li>选择分割元素$D_s$，划分为左右子序列左子序列所有元素小于$D_s$右子序列所有元素大于$D_s$</li><li>子序列快速排序</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int Partition(List *list, int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int i = low;</span><br><span class="line">    int j = high+1;</span><br><span class="line">    Entry pivot = list-&gt;D[low]; // pivot是分割元素</span><br><span class="line">    do&#123;</span><br><span class="line">        do</span><br><span class="line">            i++;</span><br><span class="line">        while(list-&gt;D[i].key &lt; pivot.key &amp;&amp; i &lt;= high); // i前进</span><br><span class="line">        do</span><br><span class="line">            j--;</span><br><span class="line">        while(list-&gt;D[i].key &gt; pivot.key &amp;&amp; j &gt;= low); // i前进</span><br><span class="line">        if(i &lt; j)</span><br><span class="line">            Swap(list-&gt;D, i, j);</span><br><span class="line">    &#125;while(i &lt; j);</span><br><span class="line">    Swap(list-&gt;D, low, j);</span><br><span class="line">    return j; // j是分割元素下标</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两路合并">两路合并</h3><p>对$[\dfrac{n}{2^{i-1}}]$个有序序列，合并$(D[0],…,D[2^{i-1}-1])$和$(D[2^{i-1}],…,D[2^{i}-1])$</p><ul><li>若$[\dfrac{n}{2^{i-1}}]$是偶数，合并最后两个有序序列，否则最后一个序列不合并</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*子序列合并*/</span><br><span class="line">void Merge(List *list, Entry *temp, int low, int n1, int n2)</span><br><span class="line">&#123;</span><br><span class="line">    int i =low, j = low + n1; // i,j初始时分别指向两个序列第一个元素</span><br><span class="line">    while( i &lt;= low + n1 -1 &amp;&amp; j &lt;= low + n1 + n2 -1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(list-&gt;D[i].key &lt;= list-&gt;D[j].key)</span><br><span class="line">            *temp++ = list-&gt;D[i++];</span><br><span class="line">        else</span><br><span class="line">            *temp++ = list-&gt;D[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(i &lt;= low + n1 - 1)</span><br><span class="line">        *temp++ = list-&gt;D[i++]; // 剩余元素直接拷贝至temp</span><br><span class="line">    while(j &lt;= low + n1 + n2 -1)</span><br><span class="line">        *temp++ = list-&gt;D[j++]; // 剩余元素直接拷贝至temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MergeSort(List *list)</span><br><span class="line">&#123;</span><br><span class="line">    Entry temp[MaxSize];</span><br><span class="line">    int low, n1, n2, i, size = 1;</span><br><span class="line">    while(size &lt; list-&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        low = 0; // low是一对待合并序列第一个序列第一个下标</span><br><span class="line">        while(low + size &lt; list-&gt;n) // 至少两个序列要合并</span><br><span class="line">        &#123;</span><br><span class="line">            n1 = size;</span><br><span class="line">            if(low + size*2 &lt; list-&gt;n)</span><br><span class="line">                n2 = size; // 计算第二个序列长度</span><br><span class="line">            else</span><br><span class="line">                n2 = list-&gt;n - low -size;</span><br><span class="line">            Merge(list, temp+low, low, n1, n2);</span><br><span class="line">            low += n1 + n2; // 确定下一对待合并序列中第一个序列第一个元素下标</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=0 ; i&lt;low ; i++)</span><br><span class="line">            list-&gt;D[i] = temp[i]; // 复制一趟合并排序结果</span><br><span class="line">        size *= 2; // 子序列长度翻倍</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序">堆排序</h3><p><img src="https://raw.githubusercontent.com/picpo/blog-PicGo/master/202212242310122.png" alt=""></p><h3 id="总结-2">总结</h3><p>排序算 法</p><p>各趟排序结果</p><p>算法的稳定性</p><p>时间复杂度（平均/最好/最坏）</p><p>适用场合</p><p>一趟排序确定元素位置</p><p>简单选择排序</p><p>$n-1$</p><p>不稳定</p><p>平均：$O(n^2)$ 最好：$O(n^2)$ 最坏：$O(n^2)$</p><p>无</p><p>√</p><p>插入排序</p><p>$n-1$</p><p>稳定</p><p>平均：$O(n^2)$ 最好：$O(n)$ 最坏：$O(n^2)$</p><p>待排序序列基本有序递增</p><p>×</p><p>冒泡排序</p><p>$1$$~$$n-1$</p><p>稳定</p><p>平均：$O(n^2)$ 最好：$O(n)$ 最坏：$O(n^2)$</p><p>基本有序且简单快速实现</p><p>√</p><p>快速排序</p><p>${\geq}n-1$</p><p>不稳定</p><p>平均：$O(nlog_2n)$ 最好：$O(log_2n)$ 最坏：$O(n^2)$</p><p>非常无序</p><p>√</p><p>合并排序</p><p>$$[log_2n]$$</p><p>稳定</p><p>平均：$O(nlog_2n)$ 最好：$O(nlog_2n)$ 最坏：$O(nlog_2n)$</p><p>多数场合，不要节省空间</p><p>×</p><p>堆排序</p><p>不稳定</p><p>平均：$O(nlog_2n)$ 最好：$O(nlog_2n)$ 最坏：$O(nlog_2n)$</p><p>√</p>]]></content>
    
    
    <summary type="html">感受
考试感觉有手就行，20分钟写完，结果就96，乐



绪论
逻辑结构
1. 线性结构 1:1
2. 树形结构 1:n
3. 图结构 m:n
4. 集合结构 没啥关系



分成两类：线性数据结构与非线性数据结构（废话）

存储结构
1. 顺序存储结构 依次存储
2. 链式存储结构 连续的或不连续的存储空间

算法时间复杂度
$$O&#92;left(1&#92;right)&lt;O&#92;left(&#92;log_2n&#92;right)&lt;O&#92;left(n&#92;right)&lt;O&#92;left(n&#92;log_2n&#92;right)&lt;O&#92;left(n^2&#92;right)&lt;O&#92;left(n^3&#92;right)&lt;O&#92;left(n!&#92;right)&lt;O&#92;</summary>
    
    
    
    <category term="我爱学习" scheme="https://picpo.top/categories/%E6%88%91%E7%88%B1%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="速通指南" scheme="https://picpo.top/tags/%E9%80%9F%E9%80%9A%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
</feed>
